<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS基础知识储备-六</title>
      <link href="/posts/faef.html"/>
      <url>/posts/faef.html</url>
      
        <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们 JavaScript 中有一些事件，比如浏览器的 resize、scroll 事件，鼠标的 mousemove、mouseover 事件以及输入框的 keypress、keyup 事件，它们在触发的时候会不断调用事件绑定的回调函数，极大的浪费资源，降低前端性能。为了优化用户体验，我们需要对这类事件进行调用次数的限制。我们可以使用防抖与节流来降低事件的触发频率。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>当连续触发事件时，事件被触发 N 秒后才执行回调，否则如果在这 n 秒内又被触发，则重新计时</p></blockquote><p>例：鼠标移动事件<br>正常情况：从开始监听到鼠标不再移动打印出无数次<br>防抖处理：只在鼠标不再移动后 N 秒打印出鼠标最后停止的位置（N 秒为人为设置）</p><h3 id="2、为什么要防抖？"><a href="#2、为什么要防抖？" class="headerlink" title="2、为什么要防抖？"></a>2、为什么要防抖？</h3><p>在某一函数在短时间内被连续触发导致占用大量性能使得系统卡顿，而我们并不真正需要连续触发这个函数。我们需要的是连续触发中最后一次的结果，这时我们使用防抖来优化函数的触发，达到减少占用性能，防止连续触发导致的卡顿。</p><h3 id="3、防抖的实现"><a href="#3、防抖的实现" class="headerlink" title="3、防抖的实现"></a>3、防抖的实现</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 防抖</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> _args <span class="token operator">=</span> args<span class="token punctuation">;</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    fun<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h3><p>移动鼠标，更新数字，数字记录调用事件回调次数</p><h4 id="4-1-正常调用"><a href="#4-1-正常调用" class="headerlink" title="4.1 正常调用"></a>4.1 正常调用</h4><p>每次移动都会调用回调。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 容器</span><span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数字容器</span><span class="token keyword">const</span> numid <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  num <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  numid<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> num<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> wrapFun <span class="token operator">=</span> callback<span class="token punctuation">;</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mousemove"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">wrapFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335//fellow-travellers/picgorepo/uploads/185bf4b755fc069adfd698649b93f36d/debounce.gif" alt="正常调用"></p><h4 id="4-2-防抖调用"><a href="#4-2-防抖调用" class="headerlink" title="4.2 防抖调用"></a>4.2 防抖调用</h4><p>每次移动间隔超过 1000ms 才会调用回调，反之重新计算时间。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 容器</span><span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数字容器</span><span class="token keyword">const</span> numid <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  num <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  numid<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> num<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> wrapFun <span class="token operator">=</span> <span class="token function">dobounce</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mousemove"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">wrapFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335//fellow-travellers/picgorepo/uploads/c99763e9bf174beda77646627c248489/debounce-1.gif" alt="防抖实现"></p><h3 id="4-3-防抖优化"><a href="#4-3-防抖优化" class="headerlink" title="4.3 防抖优化"></a>4.3 防抖优化</h3><p>首次调用立即执行</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 防抖</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> _args <span class="token operator">=</span> args<span class="token punctuation">;</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果已经执行过，不再执行</span>      <span class="token keyword">const</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>fun<span class="token punctuation">.</span>id<span class="token punctuation">;</span>      fun<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fun<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      fun<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335//fellow-travellers/picgorepo/uploads/4a3481e7e3ba036f7f908cd33c448a6a/debounce-4.gif" alt="防抖优化"></p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote><p>当连续触发事件时，每隔 N 时间，触发一次函数</p></blockquote><p>例：监听鼠标在屏幕中的位置并打印，连续不断的移动鼠标一段时间，获取鼠标的移动轨迹<br>正常情况：从开始监听到鼠标不再移动打印出无数次，（轨迹最为精细）<br>节流处理：当我们不需要这样精确的轨迹时，每隔 N 秒触发一次函数打印鼠标位置，得到较为粗糙的鼠标轨迹（N 秒为人为设置）</p><h3 id="2、为什么要节流？"><a href="#2、为什么要节流？" class="headerlink" title="2、为什么要节流？"></a>2、为什么要节流？</h3><p>同样的，也是为了防止在某一函数在短时间内被连续触发导致占用大量性能使得系统卡顿，而我们并不真正需要连续触发这个函数。我们需要的是稳定的每隔一段时间触发一次，这时我们使用节流来优化函数的触发，达到减少占用性能，防止连续触发导致的卡顿。</p><h3 id="3、节流的实现"><a href="#3、节流的实现" class="headerlink" title="3、节流的实现"></a>3、节流的实现</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 节流</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> last<span class="token punctuation">,</span> deferTimer<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> _args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保证第一次执行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">&amp;&amp;</span> now <span class="token operator">&lt;</span> last <span class="token operator">+</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>deferTimer<span class="token punctuation">)</span><span class="token punctuation">;</span>      deferTimer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        last <span class="token operator">=</span> now<span class="token punctuation">;</span>        fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      last <span class="token operator">=</span> now<span class="token punctuation">;</span>      fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、示例-1"><a href="#4、示例-1" class="headerlink" title="4、示例"></a>4、示例</h3><p>移动鼠标，更新数字，数字记录调用事件回调次数</p><h4 id="4-1-节流调用"><a href="#4-1-节流调用" class="headerlink" title="4.1 节流调用"></a>4.1 节流调用</h4><p>首次调用立即执行，每隔 1000ms 调用一次。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 容器</span><span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数字容器</span><span class="token keyword">const</span> numid <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  num <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  numid<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> num<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> wrapFun <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mousemove"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">wrapFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335//fellow-travellers/picgorepo/uploads/283433d84cf67262d8f4f54d908d4f05/throttle1.gif" alt="节流调用"></p><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>lodash 的防抖与节流实现</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 防抖</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> lastArgs<span class="token punctuation">,</span>    lastThis<span class="token punctuation">,</span>    maxWait<span class="token punctuation">,</span>    result<span class="token punctuation">,</span>    timerId<span class="token punctuation">,</span>    lastCallTime<span class="token punctuation">,</span>    lastInvokeTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    leading <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    maxing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    trailing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> func <span class="token operator">!=</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>FUNC_ERROR_TEXT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  wait <span class="token operator">=</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    leading <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>leading<span class="token punctuation">;</span>    maxing <span class="token operator">=</span> <span class="token string">"maxWait"</span> <span class="token keyword">in</span> options<span class="token punctuation">;</span>    maxWait <span class="token operator">=</span> maxing      <span class="token operator">?</span> <span class="token function">nativeMax</span><span class="token punctuation">(</span><span class="token function">toNumber</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>maxWait<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>      <span class="token punctuation">:</span> maxWait<span class="token punctuation">;</span>    trailing <span class="token operator">=</span> <span class="token string">"trailing"</span> <span class="token keyword">in</span> options <span class="token operator">?</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>trailing <span class="token punctuation">:</span> trailing<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">invokeFunc</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> lastArgs<span class="token punctuation">,</span>      thisArg <span class="token operator">=</span> lastThis<span class="token punctuation">;</span>    lastArgs <span class="token operator">=</span> lastThis <span class="token operator">=</span> undefined<span class="token punctuation">;</span>    lastInvokeTime <span class="token operator">=</span> time<span class="token punctuation">;</span>    result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">leadingEdge</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lastInvokeTime <span class="token operator">=</span> time<span class="token punctuation">;</span>    timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerExpired<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> leading <span class="token operator">?</span> <span class="token function">invokeFunc</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">:</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">remainingWait</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeSinceLastCall <span class="token operator">=</span> time <span class="token operator">-</span> lastCallTime<span class="token punctuation">,</span>      timeSinceLastInvoke <span class="token operator">=</span> time <span class="token operator">-</span> lastInvokeTime<span class="token punctuation">,</span>      timeWaiting <span class="token operator">=</span> wait <span class="token operator">-</span> timeSinceLastCall<span class="token punctuation">;</span>    <span class="token keyword">return</span> maxing      <span class="token operator">?</span> <span class="token function">nativeMin</span><span class="token punctuation">(</span>timeWaiting<span class="token punctuation">,</span> maxWait <span class="token operator">-</span> timeSinceLastInvoke<span class="token punctuation">)</span>      <span class="token punctuation">:</span> timeWaiting<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">shouldInvoke</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeSinceLastCall <span class="token operator">=</span> time <span class="token operator">-</span> lastCallTime<span class="token punctuation">,</span>      timeSinceLastInvoke <span class="token operator">=</span> time <span class="token operator">-</span> lastInvokeTime<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      lastCallTime <span class="token operator">===</span> undefined <span class="token operator">||</span>      timeSinceLastCall <span class="token operator">>=</span> wait <span class="token operator">||</span>      timeSinceLastCall <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>      <span class="token punctuation">(</span>maxing <span class="token operator">&amp;&amp;</span> timeSinceLastInvoke <span class="token operator">>=</span> maxWait<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">timerExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> time <span class="token operator">=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldInvoke</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">trailingEdge</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerExpired<span class="token punctuation">,</span> <span class="token function">remainingWait</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">trailingEdge</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    timerId <span class="token operator">=</span> undefined<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>trailing <span class="token operator">&amp;&amp;</span> lastArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">invokeFunc</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    lastArgs <span class="token operator">=</span> lastThis <span class="token operator">=</span> undefined<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timerId <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    lastInvokeTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    lastArgs <span class="token operator">=</span> lastCallTime <span class="token operator">=</span> lastThis <span class="token operator">=</span> timerId <span class="token operator">=</span> undefined<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> timerId <span class="token operator">===</span> undefined <span class="token operator">?</span> result <span class="token punctuation">:</span> <span class="token function">trailingEdge</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">debounced</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> time <span class="token operator">=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      isInvoking <span class="token operator">=</span> <span class="token function">shouldInvoke</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    lastArgs <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    lastThis <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    lastCallTime <span class="token operator">=</span> time<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isInvoking<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>timerId <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">leadingEdge</span><span class="token punctuation">(</span>lastCallTime<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>maxing<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span><span class="token punctuation">;</span>        timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerExpired<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">invokeFunc</span><span class="token punctuation">(</span>lastCallTime<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timerId <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>      timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerExpired<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  debounced<span class="token punctuation">.</span>cancel <span class="token operator">=</span> cancel<span class="token punctuation">;</span>  debounced<span class="token punctuation">.</span>flush <span class="token operator">=</span> flush<span class="token punctuation">;</span>  <span class="token keyword">return</span> debounced<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 节流</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> leading <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    trailing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> func <span class="token operator">!=</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>FUNC_ERROR_TEXT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    leading <span class="token operator">=</span> <span class="token string">"leading"</span> <span class="token keyword">in</span> options <span class="token operator">?</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>leading <span class="token punctuation">:</span> leading<span class="token punctuation">;</span>    trailing <span class="token operator">=</span> <span class="token string">"trailing"</span> <span class="token keyword">in</span> options <span class="token operator">?</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>trailing <span class="token punctuation">:</span> trailing<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> <span class="token punctuation">{</span>    leading<span class="token punctuation">:</span> leading<span class="token punctuation">,</span>    maxWait<span class="token punctuation">:</span> wait<span class="token punctuation">,</span>    trailing<span class="token punctuation">:</span> trailing<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/lodash/lodash" target="_blank" rel="noopener">lodash 的实现</a><br><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">可视化防抖与节流</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">防抖</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备-五</title>
      <link href="/posts/d86f.html"/>
      <url>/posts/d86f.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、浏览器渲染过程"><a href="#1、浏览器渲染过程" class="headerlink" title="1、浏览器渲染过程"></a>1、浏览器渲染过程</h1><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png" alt=""></p><p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li></ul><p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p><h2 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h2><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%E6%A0%91.png" alt=""></p><p>为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li>从DOM树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p><ul><li>一些不会渲染输出的节点，比如script、meta、link等。</li><li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li></ul><p><strong>注意：渲染树只包含可见的节点</strong></p><h1 id="2、回流与重绘"><a href="#2、回流与重绘" class="headerlink" title="2、回流与重绘"></a>2、回流与重绘</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ul><li>回流：当render tree中的一部分（或全部），因为元素的规模尺寸、布局、隐藏等改变而需要重新构建，这就是回流（reflow）</li><li>重绘：回流完成后，浏览器会重新绘制受影响的部分，这就是重绘过程。<br>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不影响布局，则称为重绘（repaints）</li></ul><h2 id="2、何时发生回流重绘"><a href="#2、何时发生回流重绘" class="headerlink" title="2、何时发生回流重绘"></a>2、何时发生回流重绘</h2><p>当页面布局和几何属性改变时就需要回流</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化（offsetWidth、offsetHeight）</li><li>元素尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化（文本、图片、input框）</li><li>页面渲染初始化</li><li>浏览器窗口尺寸改变（回流是根据视口的大小来计算元素的位置和大小的）</li><li>增加或移除样式表</li><li>操作class属性</li><li>改变字体</li><li>激活伪类（如：hover）</li></ul><p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong><br>（比如在body最前面插入一个元素，会导致整个render tree回流，如果在body后面插入一个元素，则不会影响前面元素的回流）</p><h2 id="3、浏览器的优化机制"><a href="#3、浏览器的优化机制" class="headerlink" title="3、浏览器的优化机制"></a>3、浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle() 或者 IE中：currentStyle</li><li>getBoundingClientRect</li><li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">https://gist.github.com/pauli…</a></li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p><h1 id="3、如何减少回流重绘"><a href="#3、如何减少回流重绘" class="headerlink" title="3、如何减少回流重绘"></a>3、如何减少回流重绘</h1><h2 id="1、最小化重绘"><a href="#1、最小化重绘" class="headerlink" title="1、最小化重绘"></a>1、最小化重绘</h2><p>减少对render tree的操作，并减少一些对style信息的请求，合理利用浏览器的优化策略</p><pre><code>const el = document.getElementById('test');el.style.padding = '5px';el.style.borderLeft = '1px';el.style.borderRight = '2px';</code></pre><ul><li><p>使用cssText</p><pre><code>const el = document.getElementById('test');el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';</code></pre></li><li><p>修改CSS的classname</p><pre><code>const el = document.getElementById('test');el.className += ' active';</code></pre></li></ul><h2 id="2、批量处理DOM"><a href="#2、批量处理DOM" class="headerlink" title="2、批量处理DOM"></a>2、批量处理DOM</h2><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p><ol><li>使元素脱离文档流</li><li>对其进行多次修改</li><li>将元素带回到文档中。</li></ol><p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。</p><p>有三种方式可以让DOM脱离文档流：</p><ul><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li><li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ul><h2 id="3、避免触发同步布局事件"><a href="#3、避免触发同步布局事件" class="headerlink" title="3、避免触发同步布局事件"></a>3、避免触发同步布局事件</h2><p>当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p><pre><code>function initP() {    for (let i = 0; i &lt; paragraphs.length; i++) {        paragraphs[i].style.width = box.offsetWidth + 'px';    }}</code></pre><p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p><pre><code>const width = box.offsetWidth;function initP() {    for (let i = 0; i &lt; paragraphs.length; i++) {        paragraphs[i].style.width = width + 'px';    }}</code></pre><h2 id="4、对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#4、对于复杂动画效果-使用绝对定位让其脱离文档流" class="headerlink" title="4、对于复杂动画效果,使用绝对定位让其脱离文档流"></a>4、对于复杂动画效果,使用绝对定位让其脱离文档流</h2><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html" target="_blank" rel="noopener">例子</a></p><h2 id="5、css3硬件加速（GPU加速）"><a href="#5、css3硬件加速（GPU加速）" class="headerlink" title="5、css3硬件加速（GPU加速）"></a>5、css3硬件加速（GPU加速）</h2><p><strong>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li>transform</li><li>opacity</li><li>filters</li><li>Will-change<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3>我们可以先看个<a href="https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html" target="_blank" rel="noopener">例子</a>。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E7%A4%BA%E4%BE%8B%E6%88%AA%E5%9B%BE.png" alt=""><br>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li><li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。<h3 id="css3硬件加速的坑"><a href="#css3硬件加速的坑" class="headerlink" title="css3硬件加速的坑"></a>css3硬件加速的坑</h3></li><li>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</li><li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备-四</title>
      <link href="/posts/4c66.html"/>
      <url>/posts/4c66.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><h2 id="1、浏览器组成"><a href="#1、浏览器组成" class="headerlink" title="1、浏览器组成"></a>1、浏览器组成</h2><p>JAVAScript 有三部分构成，ECMAScript，DOM和BOM，根据浏览器的不同，具体的表现形式也不尽相同。</p><ol><li>DOM是 W3C 的标准; [所有浏览器公共遵守的标准]</li><li>BOM 是 各个浏览器厂商根据 DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]</li><li>window 是 BOM 对象，而非 js 对象；</li></ol><h2 id="2、DOM和BOM"><a href="#2、DOM和BOM" class="headerlink" title="2、DOM和BOM"></a>2、DOM和BOM</h2><ul><li>DOM：DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。</li><li>BOM：BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。而这些扩展则包括：<br>（1）弹出新的浏览器窗口<br>（2）移动、关闭浏览器窗口以及调整窗口大小<br>（3）提供 Web 浏览器详细信息的定位对象<br>（4）提供用户屏幕分辨率详细信息的屏幕对象<br>（5）对 cookie 的支持<br>（6）IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</li></ul><h2 id="3、两者联系"><a href="#3、两者联系" class="headerlink" title="3、两者联系"></a>3、两者联系</h2><blockquote><p>javacsript是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM（Document Object Model）模型的根节点。可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档</p></blockquote><p>网上抠了两张图（哈哈哈）：<br><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/BOM%E5%92%8CDOM%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/window%E5%AF%B9%E8%B1%A1%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt=""></p><h1 id="二、DOM基本操作"><a href="#二、DOM基本操作" class="headerlink" title="二、DOM基本操作"></a>二、DOM基本操作</h1><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AF%BC%E5%9B%BE.png" alt=""><br>接下来我们来具体学习一下DOM的基本操作</p><h2 id="（一）定义"><a href="#（一）定义" class="headerlink" title="（一）定义"></a>（一）定义</h2><p><strong>DOM:Document Object Model</strong>，即文档对象模型。DOM 里边定义了一系列方法，是用 来操作 html 和 xml 功能的一类对象的集合，也有人称 DOM 是 html 和 xml 的标准编程 接口。</p><p><strong>注意:我们所说的改变不了 css 指的是改变不了 css 样式表，但是我们可以改变 HTML 的行间样式，也就是说我们可以通过间接地改变行间样式来改变他</strong></p><h2 id="（二）DOM选择器、节点类型和属性"><a href="#（二）DOM选择器、节点类型和属性" class="headerlink" title="（二）DOM选择器、节点类型和属性"></a>（二）DOM选择器、节点类型和属性</h2><h3 id="1、DOM选择器（方法类操作）"><a href="#1、DOM选择器（方法类操作）" class="headerlink" title="1、DOM选择器（方法类操作）"></a>1、DOM选择器（方法类操作）</h3><h4 id="（1）-document-代表整个文档"><a href="#（1）-document-代表整个文档" class="headerlink" title="（1） document 代表整个文档"></a>（1） document 代表整个文档</h4><p>document 是一个对象，这个对象上边有一些属性和方法，单独的 document 就代表的是整个文档在 js 里的显示形式，我们现在所说的整个文档最顶级的标签看上 去好像是 html 标签，但是如果在 html 标签外边再套一个标签的话，这个标签就是 document，就是说 document 才是真正的代表整个文档，html 只是他下面的一个根标签。</p><p> ####（2）id 选择器<br>这个选择器和 css 里边讲的极其类似，比如说你在 html 里写上一个<br>&lt; div id=”only”&gt;123&lt; /div&gt;<br>然后在 js 里 var div = document.getElementById(“only”)</p><h4 id="（3）标签选择器"><a href="#（3）标签选择器" class="headerlink" title="（3）标签选择器"></a>（3）标签选择器</h4><p>比如说你在 HTML 里边写一个&lt; div&gt;123&lt; /div &gt;，然后在 js 里 var div = document.getElementsByTagName(“div”)</p><p><em>注意：document.getElementsByTagName(“*”)，里边可以写 *，和通配符一样，选中了所有标签</em></p><h4 id="（4）class选择器"><a href="#（4）class选择器" class="headerlink" title="（4）class选择器"></a>（4）class选择器</h4><p>他和这个标签选择器差不多，选出来也是一组，你先&lt; div class=”demo”&gt;123&lt; /div&gt;， 然后 var div = document.getElementsByClassName(“demo”)[0]，此时访问 div 就得 到&lt; div class=”demo”&gt;123&lt; /div&gt;。</p><p><em>注意：class 选择器在 ie8 和 ie8 以下的浏览器中没有，但是新版本是可以的， 所以在 js 里，class 选择器并没有标签选择器那么常用，标签选择器 getElementsByTagName 在任意一个浏览器里都好使。</em></p><h4 id="（5）name选择器"><a href="#（5）name选择器" class="headerlink" title="（5）name选择器"></a>（5）name选择器</h4><p>比如&lt; input name=”abc”&gt;，然后 var input = document.getElementsByName(“abc”)[0]， 访问 input 就得到&lt; input name=”abc”&gt;。需注意这个 name 属性只对部分元素生效，如 表单、表单元素、img 等，name 选择器很少用。</p><h4 id="（6）css选择器"><a href="#（6）css选择器" class="headerlink" title="（6）css选择器"></a>（6）css选择器</h4><p>css 选择器能让我们在 js 里选择元素的时候和 css 里一样灵活，比如说：</p><pre><code>&lt;div&gt;         &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;        &lt;span&gt;             &lt;strong&gt;&lt;/strong&gt;        &lt;/span&gt;&lt;/div&gt;</code></pre><p>然后在 js 里写上 var strong = document.querySelector(“div span strong”);括号 里写的东西就和 css 里选择标签的方法是一样的，此时访问 strong 就得到 &lt; strong&gt;&lt; /strong&gt;，这选的是一个，还有一个 var strong = document.querySelectorAll(“div span strong”);他选出来是一组，你再访问 strong 就得到 NodeList[strong]</p><p><em>注意：在 ie7 及以下的版本没有，这个对我们并没有什么影响，还有一个致命的问题，就是 这个 querySelector 和 querySelectorAll 选出来的东西不是实时的，在用法上就及其受局限，除非极特殊情况，你就想选他的副本保存起来才会用这个，否则的话我 们不用。</em></p><h3 id="2、遍历节点树（非方法类操作）"><a href="#2、遍历节点树（非方法类操作）" class="headerlink" title="2、遍历节点树（非方法类操作）"></a>2、遍历节点树（非方法类操作）</h3><h4 id="（1）parentNode-父节点"><a href="#（1）parentNode-父节点" class="headerlink" title="（1）parentNode:父节点"></a>（1）parentNode:父节点</h4><p>比如说：</p><pre><code>&lt;div&gt;    &lt;span&gt;&lt;/span&gt;    &lt;strong&gt;&lt;/strong&gt;     &lt;em&gt;&lt;/em&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    var strong = document.getElementsByTagName("strong")[0]; &lt;/script&gt;</code></pre><p>现在访问 strong.parentNode 就是他的父节点，得到&lt; div&gt;…&lt; /div&gt;，继续 strong.parentNode.parentNode 就是 div 的父亲，即&lt; body&gt;…&lt; /body&gt;，继续就是 body 的父级，即&lt; html&gt;…&lt; /html&gt;， 再就是 HTML 的父级，即 #document，再继续就得到 null，这就说明 <strong>document 就到顶层了，他是顶层的父级节点，代表整个文档</strong>。</p><h4 id="（2）childNodes-子节点们"><a href="#（2）childNodes-子节点们" class="headerlink" title="（2）childNodes 子节点们"></a>（2）childNodes 子节点们</h4><p>遍历的是节点树，并不是只有元素节点算节点，节点的类型有很多，它包括文本节点、元素节点、属性节点、注释节点 等<br>比如：</p><pre><code>&lt;div&gt;  &lt;!-- this is comment! --&gt;   &lt;strong&gt;&lt;/strong&gt;   &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;  var div = document.getElementsByTagName("div")[0]; &lt;/script&gt;</code></pre><p>访问 div.childNodes 就得到 odeList(7)[text, comment, text, strong, text, span, text]，可见他有七个节点:依次是文本节点、注释节点、文本节点、元素节点、 文本节点、元素节点、文本节点。（<em>空格文本和文本和回车文本都写在一起，就是一个文本 节点</em>）</p><h4 id="（3）firstChild-lastChild-第一个子节点-最后一个子节点"><a href="#（3）firstChild-lastChild-第一个子节点-最后一个子节点" class="headerlink" title="（3）firstChild/lastChild 第一个子节点/最后一个子节点"></a>（3）firstChild/lastChild 第一个子节点/最后一个子节点</h4><p>例如上边的，现在 div.firstChild 就是文本 123 和回车，div.lastChild 就是#text， 还是文本节点，只不过是空的，他就那样显示了。</p><h4 id="（4）nextSibling-previousSibling-后一个兄弟节点-前一个兄弟节点"><a href="#（4）nextSibling-previousSibling-后一个兄弟节点-前一个兄弟节点" class="headerlink" title="（4）nextSibling/previousSibling 后一个兄弟节点/前一个兄弟节点"></a>（4）nextSibling/previousSibling 后一个兄弟节点/前一个兄弟节点</h4><p>还是上边的，var strong = document.getElementsByTagName(“strong”)[0];，然后 strong.nextSibling 就得到#text</p><h3 id="3、遍历元素节点树"><a href="#3、遍历元素节点树" class="headerlink" title="3、遍历元素节点树"></a>3、遍历元素节点树</h3><p>这几种方法只遍历的是元素节点，其他的都不掺杂了。比如说:</p><pre><code>&lt;div&gt; 123  &lt;!-- this is comment! --&gt;   &lt;strong&gt;&lt;/strong&gt;   &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><h4 id="（1）parentElement-元素父节点"><a href="#（1）parentElement-元素父节点" class="headerlink" title="（1）parentElement 元素父节点"></a>（1）parentElement 元素父节点</h4><p>在 js 里 var div = document.getElementsByTagName(“div”)[0]; 然 后 div .parentElement 他 的 元 素 父 节 点 就 是 … ， 然 后 div.parentElement.parentElement，就是 body 的元素父节点，即…， 再父节点就是 null，因为 document 不叫 元素节点，他自称为一个节点，所以 parentNode 和 parentElement 的区别就在于有没有document。</p><h4 id="（2）children-元素子节点"><a href="#（2）children-元素子节点" class="headerlink" title="（2）children 元素子节点"></a>（2）children 元素子节点</h4><p>现在 div.children 就得到 HTMLCollection(2)[strong,span]，只有两个。</p><h4 id="（3）childElementCount-children-length-元素子节点的个数"><a href="#（3）childElementCount-children-length-元素子节点的个数" class="headerlink" title="（3）childElementCount === children.length 元素子节点的个数"></a>（3）childElementCount === children.length 元素子节点的个数</h4><p>比如说 div.childElementCount 就得到 2，你 div.children.length 也是 2，两者用法一样</p><h4 id="（4）firstElementChild-lastElementChild-第一个元素子节点-最后一个元素子节-点"><a href="#（4）firstElementChild-lastElementChild-第一个元素子节点-最后一个元素子节-点" class="headerlink" title="（4）firstElementChild/lastElementChild 第一个元素子节点/最后一个元素子节 点"></a>（4）firstElementChild/lastElementChild 第一个元素子节点/最后一个元素子节 点</h4><p>现在 div.firstElementChild 就是&lt; strong&gt;&lt; /strong&gt;，div.lastElementChild 就是 &lt; span&gt;&lt; /span&gt;。</p><h4 id="（5）nextElementSibling-previousElementSibling-后一个兄弟元素节点-前一个兄-弟元素节点"><a href="#（5）nextElementSibling-previousElementSibling-后一个兄弟元素节点-前一个兄-弟元素节点" class="headerlink" title="（5）nextElementSibling/previousElementSibling 后一个兄弟元素节点/前一个兄 弟元素节点"></a>（5）nextElementSibling/previousElementSibling 后一个兄弟元素节点/前一个兄 弟元素节点</h4><p>strong.nextElementSibling 就得到 &lt; span&gt;&lt; /span&gt;</p><p><strong>备注:以上遍历节点树的方法所有浏览器都兼容，但是遍历元素节点树的方法除 children 以外，ie9 及以下的浏览器都不兼容。</strong></p><h3 id="4、节点的四个属性"><a href="#4、节点的四个属性" class="headerlink" title="4、节点的四个属性"></a>4、节点的四个属性</h3><pre><code>&lt;div&gt;   123  &lt;!-- this is comment! --&gt;  &lt;strong&gt;&lt;/strong&gt;   &lt;span&gt;&lt;/span&gt;   &lt;em&gt;&lt;/em&gt;  &lt;i&gt;&lt;/i&gt;  &lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;  var strong = document.getElementsByTagName("strong")[0];&lt;/script&gt;</code></pre><h4 id="（1）nodeName-元素的标签名，只读"><a href="#（1）nodeName-元素的标签名，只读" class="headerlink" title="（1）nodeName 元素的标签名，只读"></a>（1）nodeName 元素的标签名，只读</h4><p>var div = document.getElementsByTagName(“div”)[0];<br>你访问 document.nodeName 就得到 “#document”，<br>访问 div.firstChild.nodeName，他是一个文本节点，就得到”#text”，<br>继续 div.childNodes[1].nodeName，第二个子节点是注释，就得到”#comment”， div.childNodes[3].nodeName 是元素节点，就得到”STRONG”。返回的是一个字符串， 只读就是只能读取不能写入，比如说我把 div.childNodes[3].nodeName = “abc”，再 访问的话还是”STRONG”。</p><h4 id="（2）nodeValue-text节点或comment节点的文本内容，可读写"><a href="#（2）nodeValue-text节点或comment节点的文本内容，可读写" class="headerlink" title="（2）nodeValue text节点或comment节点的文本内容，可读写"></a>（2）nodeValue text节点或comment节点的文本内容，可读写</h4><p>这个属性只有文本节点和注释节点才有，<br>访问 div.childNodes[0].nodeValue 就得到 文本的回车和 123，这个可以改，你 div.childNodes[0].nodeValue = “234”，<br>再访问 的话就是”234”，再比如访问 div.childNodes[1].nodeValue 就得到” this is comment! “，如果 div.childNodes[1].nodeValue = “ that is comment! “，再访问 div.childNodes[1]就是&lt;! – that is comment! –&gt;。</p><h4 id="（3）nodeType-该节点的类型，只读"><a href="#（3）nodeType-该节点的类型，只读" class="headerlink" title="（3）nodeType 该节点的类型，只读"></a>（3）nodeType 该节点的类型，只读</h4><p>比如说现在有一个节点，我也不知道里边是什么节点，就有他来分辨，每一个节点都 有这个 nodeType 属性，你调用他返回的是一个具体的值:<br><strong>元素节点是 1，<br>属性节点是 2，<br>文本节点是 3，<br>注释节点是 8，<br>document 节点是 9，<br>DocumentFragment(文档碎片节点)是 11</strong><br>现在 document.nodeType 就是 9，div.childNodes[1].nodeType 第二个是 注释节点就返回 8，div.childNodes[0].nodeType 文本节点返回 3， div.childNodes[3].nodeType 元素节点就是 1。</p><p><em>练习题<br>还是上边的例子，现在封装一个方法，要求返回 div 的直接子元素节点，但是 不允许用 children。</em></p><pre><code>function retElementChild(node) {   var temp = {              length: 0,              push: Array.prototype.push,               splice: Array.prototype.splice              },      child = node.childNodes, len = child.length;      for (var i = 0; i &lt; len; i++) {         if (child[i].nodeType === 1) {            temp.push(child[i]);             }        }    return temp; }</code></pre><h4 id="（4）attributes-元素节点的属性集合"><a href="#（4）attributes-元素节点的属性集合" class="headerlink" title="（4）attributes 元素节点的属性集合"></a>（4）attributes 元素节点的属性集合</h4><p>这个属性就是访问元素的属性节点的，<br>&lt; div id=”only” class=”demo”&gt;&lt; /div&gt;<br>然后继续把 div 选出来:var div = document.getElementsByTagName(“div”)[0];现 在 div.attributes 就得到 NamedNodeMap{0: id, 1: class, id: id, class: class, length: 2}，<br>访问 div.attributes[0]就得到 id=”only”，<br>访问 div.attributes[1]就 是 class=”demo”。<br>div.attributes[1].nodeType 就得到 2. 你也可以把他的属性名和属性值都取出来，<br>div.attributes[0].name 就得到”id”，<br>div.attributes[0].value 就得到”only”。<br><strong>属性名是只读的，属性值可读可写。</strong></p><h3 id="5、节点的一个方法-Node-hasChildNodes"><a href="#5、节点的一个方法-Node-hasChildNodes" class="headerlink" title="5、节点的一个方法 Node.hasChildNodes()"></a>5、节点的一个方法 Node.hasChildNodes()</h3><p>这个方法就是判断这个<strong>元素</strong>有没有子节点，现在 div.hasChildNodes()就返回 true， 因为空格回车文本也算文本节点，除非&lt; div id=”only” class=”demo”&gt;&lt; /div&gt;的话， 访问 div.hasChildNodes()是 false，中间啥都没有(属性节点不算，他是 div 自己的， 不能算子节点)才能返回 false。</p><h2 id="（三）DOM-继承树及基本操作"><a href="#（三）DOM-继承树及基本操作" class="headerlink" title="（三）DOM 继承树及基本操作"></a>（三）DOM 继承树及基本操作</h2><h3 id="1、DOM继承树"><a href="#1、DOM继承树" class="headerlink" title="1、DOM继承树"></a>1、DOM继承树</h3><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/dom%E7%BB%93%E6%9E%84%E6%A0%91.png" alt=""></p><ul><li>首先我们知道 document 代表的是整个文档，访问就得到#document，但是我访问 Document 就得到ƒ Document() { [native code] }，是一个构造函数。假如说你给 Document 的原型上加一些属 性的话，比如 Document.prototype.abc = “abc”，那么 document 就能继承他的属性， 你访问 document.abc 就得到”abc”，上边的结构树就表示这一系列继承的关系。</li><li>第二个 CharacterData 下边有 Text 和 Comment，这就说明文本节点能用的属性和 方法全部继承自 Text.prototype，注释节点的方法则全部继承自 Comment.prototype， 然后一层一层向上继承。</li><li>第三个最长，Element 下边有一个 HTMLElement(那下边就肯定还有一个 XMLElement， 只不过没写)，然后在下边有一堆东西，最后还没写完，但是你会发现那一堆东西都是 一些标签能用的一些属性和方法</li><li>现在 document.__ proto__得到 HTMLDocument{…}，<br>document.__ proto__.__ proto__就得到 Document{…}，<br>document.__ proto__.__ proto__.__ proto__得到 Node{…}，<br>document.__ proto__.__ proto__.__ proto__.__ proto__得到 EventTarget{…}<br>document.__ proto__.__ proto__.__ proto__.__ proto__.__ proto__就得到 Object{}. </li></ul><p><strong>这就说明 DOM 对象最终也继承自 Object.prototype，比如你访问 document.toString() 就得到”[object HTMLDocument]”，这个 Object.prototype 是所有对象原型链上的终端。</strong></p><h3 id="2、DOM-结构树的应用"><a href="#2、DOM-结构树的应用" class="headerlink" title="2、DOM 结构树的应用"></a>2、DOM 结构树的应用</h3><ol><li>getElementById 方法定义在 Document.prototype 上，即 Element 节点上不能使用</li><li>getElementsByName 方法定义在 HTMLDocument.prototype 上，即非 html 中的 document 不能使用(xml 的 document 和 Element 不能用)。</li><li>getElementsByTagName 方法定义在 Document.prototype 和 Element.prototype 上。</li></ol><p><em>解释：这个方法在两个地方都定义了，就都能用，比如说</em></p><pre><code>&lt;div&gt;  &lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;script type="text/javascript"&gt;  var div = document.getElementsByTagName('div')[0];  var span = div.getElementsByTagName("span")[0]; &lt;/script&gt;</code></pre><ol start="4"><li>HTMLDocument.prototype 定义了一些常用的属性，body,head,分别指代 HTML 文 档中的&lt; body&gt;和&lt; head&gt;标签。</li></ol><p><em>解释：要选 head 标签或者 body 标签的话就直接 document.head 或者 document.body 就可以了。</em><br>5. Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在 HTML 文档中，他总是指代&lt; html&gt;元素。<br>6. getElementsByClassName、querySelectorAll、querySelector 这几个方法在 Document.prototype 和 Element.prototype 类中均有定义。</p><p><em>练习题1：遍历元素节点树(在原型链上编程)</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;            &lt;em&gt;&lt;/em&gt;            &lt;strong&gt;                &lt;em&gt;                    &lt;a href=""&gt;&lt;/a&gt;                &lt;/em&gt;            &lt;/strong&gt;        &lt;/span&gt;        &lt;p&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;span&gt;&lt;/span&gt;    &lt;script type="text/javascript"&gt;        var div = document.getElementsByTagName('div')[0];        Element.prototype.retChildElements = function () {            var child = this.childNodes,                len = child.length;            for (var i = 0; i &lt; len; i++) {                if (child[i].nodeType === 1) {                    console.log(child[i]);                }            }        }    &lt;/script&gt;&lt;/body&gt;</code></pre><p><em>练习题2：封装函数，返回元素 a 的第 n 层祖先元素节点</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;            &lt;strong&gt;                &lt;em&gt;                    &lt;a href=""&gt;&lt;/a&gt;                &lt;/em&gt;            &lt;/strong&gt;        &lt;/span&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        var a = document.getElementsByTagName('a')[0];        function retParent(elem, n) {            while (elem &amp;&amp; n) {                elem = elem.parentElement;                n--;            }            return elem;        }    &lt;/script&gt;&lt;/body&gt;</code></pre><p><em>练习题3：编辑函数，封装 myChildren 功能，解决以前部分浏览器的兼容性问题。</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;b&gt;&lt;/b&gt;        蜡笔小新        &lt;!-- this is comment --&gt;        &lt;strong&gt;            &lt;span&gt;                &lt;i&gt;&lt;/i&gt;            &lt;/span&gt;        &lt;/strong&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        Element.prototype.myChildren = function () {            var child = this.childNodes;            var len = child.length;            var arr = [];            for (var i = 0; i &lt; len; i++) {                if (child[i].nodeType == 1) {                    arr.push(child[i]);                }            }            return arr;        }        var div = document.getElementsByTagName("div")[0];    &lt;/script&gt;&lt;/body&gt;</code></pre><p><em>练习题4：自己封装 hasChildren()方法，不可用 children 属性。</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;b&gt;&lt;/b&gt;        蜡笔小新        &lt;!-- this is comment --&gt;         &lt;strong&gt;            &lt;span&gt;                &lt;i&gt;&lt;/i&gt;            &lt;/span&gt;        &lt;/strong&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        Element.prototype.hasChildren = function () {            var child = this.childNodes;            var len = child.length;            for (var i = 0; i &lt; len; i++) {                if (child[i].nodeType == 1) {                    return true;                }            }            return false;        }        var div = document.getElementsByTagName("div")[0];    &lt;/script&gt;&lt;/body&gt;</code></pre><p><em>练习题5：封装函数，返回元素 e 的第 n 个兄弟元素节点，n 为正，返回后面的兄弟元素 节点，n 为负，返回前面的，n 为 0，返回自己。</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;&lt;/span&gt;        &lt;p&gt;&lt;/p&gt; &lt;strong&gt;&lt;/strong&gt;        &lt;!-- this is comment --&gt; &lt;i&gt;&lt;/i&gt;        &lt;address&gt;&lt;/address&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        function retSibling(e, n) {            while (e &amp;&amp; n) {                if (n &gt; 0) {                    if (e.nextElementSibling) {                        e = e.nextElementSibling;                    } else {                        for (e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e =                            e.nextSibling);                    }                    n--;                } else {                    if (e.previousElementSibling) {                        e = e.previousElementSibling;                    } else {                        for (e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling);                    }                    n++;                }            }            return e;        }        var strong = document.getElementsByTagName("strong")[0];    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="3、DOM基本操作"><a href="#3、DOM基本操作" class="headerlink" title="3、DOM基本操作"></a>3、DOM基本操作</h3><p>上边讲的所有方法都是查看操作，下边讲其他的几个操作。</p><h4 id="（1）增"><a href="#（1）增" class="headerlink" title="（1）增"></a>（1）增</h4><ul><li>创建元素节点(即创建标签):document.createElement()</li><li>创建文本节点:document.createTextNode()</li><li>创建注释节点:document.createComment()</li><li>创建文档碎片节点:document.createDocumentFragment()</li></ul><h4 id="（2）插"><a href="#（2）插" class="headerlink" title="（2）插"></a>（2）插</h4><ul><li>appendChild()：每个元素都有 appendChild 方法，这个方法就跟 push 方法一样。</li></ul><p><em>注意：appendChild 进行的是剪切操作</em></p><ul><li>父级.insertBefore(a, b)：父级调用，里边传两个参数，意思是在 b 之前插入 a</li></ul><h4 id="（3）删"><a href="#（3）删" class="headerlink" title="（3）删"></a>（3）删</h4><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;&lt;/span&gt;        &lt;strong&gt;&lt;/strong&gt;        &lt;i&gt;&lt;/i&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        var div = document.getElementsByTagName("div")[0];        var span = document.getElementsByTagName("span")[0];        var strong = document.getElementsByTagName("strong")[0];        var i = document.getElementsByTagName("i")[0];    &lt;/script&gt;&lt;/body&gt;</code></pre><ul><li>parentNode.removeChild(a) 父级删除自己的子节点<br>div.removeChild(i)后其实是把 i 标签剪切出来了，比如说上边的代码刷新后 var ii = div.removeChild(i)， 你在访问 ii 就是&lt; i&gt;&lt; /i&gt;。</li><li>a.remove()<br>比如上边代码刷新后 i.remove();strong.remove();div 里边就只剩下 span 了，remove 是真正的删除，删掉后就啥都没有了。</li></ul><h4 id="（4）替换"><a href="#（4）替换" class="headerlink" title="（4）替换"></a>（4）替换</h4><ul><li>parentNode.replaceChild(new, origin)：这个也是父级调用，里边传入两个参数，第一个是 new 就是新的，第二个是目标</li></ul><h3 id="4、Element-节点的一些属性"><a href="#4、Element-节点的一些属性" class="headerlink" title="4、Element 节点的一些属性"></a>4、Element 节点的一些属性</h3><h4 id="（1）innerHTML"><a href="#（1）innerHTML" class="headerlink" title="（1）innerHTML"></a>（1）innerHTML</h4><p>这个属性可以改变 html 里的内容，这个 innerHTML 取得是 HTML 结构，是可读写的，所以你写进去什么东西他都会识别成 HTML 结构。</p><h4 id="（2）innerText"><a href="#（2）innerText" class="headerlink" title="（2）innerText"></a>（2）innerText</h4><p>这个赋值的话里边的东西就全部被覆盖了，所以在用这个方法的时候需要谨慎， 如果标签底下有其他子标签，最好在赋值的时候不要用这个。<br><em>还有这个 innerText 老 版本的火狐浏览器不兼容，当时火狐有一个属性 textContent 和这个作用是一样的，但是火狐这个方法老版本的 ie 不好使(都是老版本的兼容性问题，现在的新版本不存 在不兼容的)。</em></p><h3 id="5、Element-节点的一些方法"><a href="#5、Element-节点的一些方法" class="headerlink" title="5、Element 节点的一些方法"></a>5、Element 节点的一些方法</h3><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script type="text/javascript"&gt;        var div = document.getElementsByTagName("div")[0];    &lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="（1）元素-setAttribute-添加属性"><a href="#（1）元素-setAttribute-添加属性" class="headerlink" title="（1）元素.setAttribute() 添加属性"></a>（1）元素.setAttribute() 添加属性</h4><p>现在 div.setAttribute(“class”,”demo”)，括号里第一个是属性名，第二个是属性值， 在访问 div 就得到&lt; div class=”demo”&gt;&lt; /div&gt;，继续 div.setAttribute(“id”,”only”)， 在访问 div 就是&lt; div class=”demo” id=”only”&gt;&lt; /div&gt;。</p><h4 id="（2）元素-getAttribute-查看属性"><a href="#（2）元素-getAttribute-查看属性" class="headerlink" title="（2）元素.getAttribute() 查看属性"></a>（2）元素.getAttribute() 查看属性</h4><p>接着上边的，现在 div.getAttribute(“id”)就得到”only”，div.getAttribute(“class”) 就得到”demo”。<br>有了这些操作，就更灵活了，比如说我在 css 里定义了一个 class 样式，然后可以再 js 里动态的添加 class 属性，让这个样式作用在对应的元素上。</p><p><em>练习题1：封装函数 insertAfter()，功能类似 insertBefore(). 提示:可忽略老版本浏览器，直接在 Element.prototype 上编程。</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;&lt;/span&gt;        &lt;i&gt;&lt;/i&gt;        &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        var div = document.getElementsByTagName("div")[0];        var b = document.getElementsByTagName("b")[0];        var strong = document.getElementsByTagName("strong")[0];        Element.prototype.insertAfter = function (targetNode, afterNode) {            var beforeNode = afterNode.nextElementSibling;            if (beforeNode == null) {                this.appendChild(targetNode);            } else {                this.insertBefore(targetNode, beforeNode);            }        }        var p = document.createElement("p");    &lt;/script&gt;&lt;/body&gt;</code></pre><p><em>练习题2：将目标节点的内部节点逆序</em></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;&lt;/span&gt; &lt;i&gt;&lt;/i&gt;        &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;        var div = document.getElementsByTagName("div")[0];        Element.prototype.inversElement = function () {            var len = this.children.length;            for (var i = len - 1; i &gt;= 0; i--) {                this.appendChild(this.children[i]);            }        }    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="三、获取窗口属性、获取-DOM-尺寸、脚本化-CSS"><a href="#三、获取窗口属性、获取-DOM-尺寸、脚本化-CSS" class="headerlink" title="三、获取窗口属性、获取 DOM 尺寸、脚本化 CSS"></a>三、获取窗口属性、获取 DOM 尺寸、脚本化 CSS</h1><h2 id="1、查看滚动条的滚动距离"><a href="#1、查看滚动条的滚动距离" class="headerlink" title="1、查看滚动条的滚动距离"></a>1、查看滚动条的滚动距离</h2><ul><li><strong>标准方法 : window.pageXOffset window.pageYOffset</strong></li></ul><p>但是以上两种方法 ie8 及 ie8 以下浏览器不兼容，这些浏览器提供了两种方法:</p><ul><li>document.body.scrollLeft(和 window.pageXOffset 效果一样)<br>document.body.scrollTop(和 window.pageYOffset 效果一样)</li><li>document.documentElement.scrollLeft<br>document.documentElement.scrollTop</li></ul><p><em>注意：以上两种方法兼容性比较混乱，就是 ie8 及 ie8 以下的浏览器有的浏览器版本第一个 方法好使，有的版本第二个方法好使，但是任何一个浏览器版本只要一种方法好使， 返回的有值，另一种不好使的方法返回的一定是 0，所以咱们在 ie8 及 ie8 以下的浏览 器不管哪个版本直接把两个值相加就行了。</em></p><p><em>练习题：封装兼容性方法，求滚动条滚动距离 getScrollOffset()</em></p><pre><code>function getScrollOffset() {            if (window.pageXOffset) {                return {                    x: window.pageXOffset,                    y: window.pageYOffset                }            } else {                return {                    x: document.body.scrollLeft + document.documentElement.scrollLeft,                    y: document.body.scrollTop + document.documentElement.scrollTop                }            }        }</code></pre><h2 id="2、查看可视区窗口尺寸"><a href="#2、查看可视区窗口尺寸" class="headerlink" title="2、查看可视区窗口尺寸"></a>2、查看可视区窗口尺寸</h2><p>可视区窗口就是咱们编写的 html 文档能看到的部分，不包括菜单栏、地址栏和控制台。 </p><ul><li><strong>标准方法:window.innerWidth window.innerHeight</strong></li></ul><p><em>注意：以上两个方法还是 ie8 及 ie8 以下版本不兼容。这些浏览器版本提供了 两种方法，一种是在标准模式下用的，一种是在怪异模式下用的。</em></p><blockquote><p>备注:什么是怪异模式?比如说在很久以前 ie7 还没有诞生，我写了一个页面，语法 全部用的是 ie6 的语法，但是一年之后 ie7 诞生了，人们都开始用新的浏览器，那么 我之前写的那个页面的部分语法就不能用了，因为有冲突，重写的话又太浪费时间， 后来人们研究了一种新的渲染模式叫怪异模式，比如说现在我启动了怪异模式，在这 个模式下即使人们用的是 ie7 浏览器，他也能根据 ie6 的语法把这个页面渲染出来， 这个怪异模式也叫混杂模式，这个模式一经启动他识别的就不是现在的语法而是之前 的语法，起到了一个向后兼容的作用，兼容之前的语法。那么怎么启用怪异模式?其 实我们在讲 html 的时候他第一行应该是&lt; !DOCTYPE html&gt;，这个我们一直没说，其实 有这一行就是标准模式，要想启动怪异模式，直接把这一行删掉即可。</p></blockquote><ul><li>第一种:标准模式下，任意浏览器都能兼容<br>document.documentElement.clientWidth<br>document.documentElement.clientHeight </li><li>第二种:适用于怪异模式下的浏览器<br>document.body.clientWidth<br>document.body.clientHeight</li></ul><p><em>怎么区分标准模式和怪异模式?<br>document 上有个属性 compatMode，在标准模式下访问 document.compatMode 得”CSS1Compat”，在怪异模式下访问 document.compatMode 得 “BackCompat”。</em></p><p><em>练习题：封装兼容性方法，返回浏览器视口尺寸 getViewportOffset()</em></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getViewportOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    w<span class="token punctuation">:</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">,</span>                    h<span class="token punctuation">:</span> window<span class="token punctuation">.</span>innerHeight                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>compatMode <span class="token operator">===</span> <span class="token string">"BackCompat"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        w<span class="token punctuation">:</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>                        h<span class="token punctuation">:</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        w<span class="token punctuation">:</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>                        h<span class="token punctuation">:</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h2 id="3、查看元素几何尺寸"><a href="#3、查看元素几何尺寸" class="headerlink" title="3、查看元素几何尺寸"></a>3、查看元素几何尺寸</h2><ul><li><strong>dom.getBoundingClientRect()</strong></li></ul><p>返回的是一个对象，对象里边有 left、top、right、bottom 等属性，left 和 top 代表该元素左上角的 X 和 Y 坐标，right 和 buttom 代表元素右下角的 X 和 Y 坐标， 这个方法兼容性很好，但是老版本的 ie 里并没有 height 和 width，所以我们在老版本 的 ie 只能计算来求宽高，而且这个方法返回的结果并不是实时的，比如说我 var box = div. getBoundingClientRect();div.style.width = “200px”，再访问 box 的话里边 的 width 还是 100px，所以他不是实时的。</p><h2 id="4、查看元素的尺寸"><a href="#4、查看元素的尺寸" class="headerlink" title="4、查看元素的尺寸"></a>4、查看元素的尺寸</h2><ul><li><strong>dom.offsetWidth dom.offsetHeight</strong></li></ul><h2 id="5、查看元素的位置"><a href="#5、查看元素的位置" class="headerlink" title="5、查看元素的位置"></a>5、查看元素的位置</h2><ul><li><strong>dom.offsetLeft dom.offsetTop</strong></li></ul><h2 id="6、滚动条滚动"><a href="#6、滚动条滚动" class="headerlink" title="6、滚动条滚动"></a>6、滚动条滚动</h2><p>window上有三个方法:</p><ul><li><strong>window.scroll()</strong></li><li><strong>window.scrollTo()</strong> </li><li><strong>window.scrollBy()</strong></li></ul><p>用法都是将 x、y 坐标传入，即实现让滚动条滚动到当前位置。<br><em>window.scroll()和 window.scrollTo()两个方法完全一样，兼容性也一样，比如说 window.scroll(0,100)他就能让 y 方向的滚动条滚动到 100 像素这个位置，你继续 window.scroll(0,100)他是不变的，说明他是让滚动条滚动到当前位置。<br>而 window.scrollBy()是累加滚动当前距离，比如说 window.scrollBy(0,10)他是让滚 动条向下滚动 10 像素，继续 window.scrollBy(0,10)就继续向下滚动 10 像素，继续 window.scrollBy(0,-10)就又向上滚动 10 像素。</em></p><p><em>练习题：模仿手机阅读器，做一个自动阅读的功能</em></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token string">"width:100px;height:100px;background-color:orange;color:#fff;font-si ze:40px;font-weight:bold;text-align:center;line-height:100px;position:fixe d;bottom:200px;right:50px;border-radius: 50%;opacity:0.5;"</span><span class="token operator">></span>        start<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div        style<span class="token operator">=</span><span class="token string">"width:100px;height:100px;background-color:#0f0;color:#fff;font-size :40px;font-weight:bold;text-align:center;line-height:100px;position:fixed; bottom:50px;right:50px;border-radius: 50%;opacity:0.5;"</span><span class="token operator">></span>        stop<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">var</span> start <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> stop <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> key <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        start<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>                timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    window<span class="token punctuation">.</span><span class="token function">scrollBy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            key <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        stop<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            key <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span></code></pre><h2 id="7、脚本化css"><a href="#7、脚本化css" class="headerlink" title="7、脚本化css"></a>7、脚本化css</h2><h3 id="（1）读写元素css属性-dom-style"><a href="#（1）读写元素css属性-dom-style" class="headerlink" title="（1）读写元素css属性 dom.style"></a>（1）读写元素css属性 dom.style</h3><p>任何一个 dom 元素都会有 style 属性，我们在控制台访问 div.style 得到，这个 dom.style 没有任何兼容性问题，但是注意碰到 float 这样的保留字属性，前边 应该加上 css，如 div.style.cssFloat = “right”。还有就是复合属性(如 border) 最好把他拆解开设置，但是现在写在一起也是可以的，最好把他拆解开。</p><h3 id="（2）查询计算样式"><a href="#（2）查询计算样式" class="headerlink" title="（2）查询计算样式"></a>（2）查询计算样式</h3><ul><li><strong>window.getComputedStyle(dom,null)</strong></li></ul><p>这个方法需要传入两个参数，第一个是 dom 元素，第二个是 null，返回的也是一个样式表，但是和上边的不一样，style 里读的只是行间里的样式，假如说你在行间没有设置的话他就没有值，但是这个方法返回的属性里即使你没有设置他也是有值的，是默认值，这个方法获取的是当前元素所展示的一切 css 的显示值， 就是假如说你通过多个选择器给一个元素设置了一个属性，那么只有权重最高的那个 起作用，而这个方法获取的只是那个起作用的也就是显示的那个值和一些默认值。这个方法 ie8 及 ie8 以下不兼容。</p><p><em>这个方法第二个参数是干嘛的吗?为啥要传 null 呢?第二个参数传对了，可以获取伪元素的样式</em></p><h3 id="（3）查询样式"><a href="#（3）查询样式" class="headerlink" title="（3）查询样式"></a>（3）查询样式</h3><ul><li><strong>dom.currentStyle (ie 独有的属性)</strong></li></ul><p>这个是 ie 独有的属性，他也能返回一个样式表，和 window.getComputedStyle()方法 类似，也是只能读取不能写入，他获取的也是最终展示的那个值，但是他返回的计算 样式的值不是经过转换的绝对值，写啥就展示啥。</p><p><em>练习题：做一个小木块运动。</em></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"width:100px;height:100px;background-color:red;position:absolute;"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">function</span> <span class="token function">getStyle</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>getComputedStyle<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> elem<span class="token punctuation">.</span>currentStyle<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> speed <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            speed <span class="token operator">+</span><span class="token operator">=</span> speed <span class="token operator">/</span> <span class="token number">7</span><span class="token punctuation">;</span>            div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">getStyle</span><span class="token punctuation">(</span>div<span class="token punctuation">,</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> speed <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">getStyle</span><span class="token punctuation">(</span>div<span class="token punctuation">,</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备-三</title>
      <link href="/posts/b1ae.html"/>
      <url>/posts/b1ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、异步编程"><a href="#一、异步编程" class="headerlink" title="一、异步编程"></a>一、异步编程</h1><h2 id="1、异步的概念"><a href="#1、异步的概念" class="headerlink" title="1、异步的概念"></a>1、异步的概念</h2><p>异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。</p><p>在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。<br>简单来理解就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效果更高。</p><p>以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：断续执行。<br>如果有异步方法会跳过，在等待回调结果后，在适当时机执行<br><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.png" alt="同步异步"></p><h2 id="2、什么时候用异步编程"><a href="#2、什么时候用异步编程" class="headerlink" title="2、什么时候用异步编程"></a>2、什么时候用异步编程</h2><p>在编程中，我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p><p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。<br>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p><h2 id="3、回调函数"><a href="#3、回调函数" class="headerlink" title="3、回调函数"></a>3、回调函数</h2><p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p><pre><code>setTimeout(function () {    console.log("蜡笔小新！");}, 1000);console.log("你真帅！");</code></pre><h1 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h1><h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><h3 id="（1）背景"><a href="#（1）背景" class="headerlink" title="（1）背景"></a>（1）背景</h3><p>由于JavaScript单线程的“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现，并在将来的某个时间点触发一个函数调用。AJAX就是典型的异步操作，如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">success</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fail</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> request<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 状态发生变化时，函数被回调</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 成功完成</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">success</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">fail</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// HTTP请求还在继续...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p><p>更好的写法：统一执行AJAX逻辑，不关心如何处理结果，然后根据结果是成果还是失败在将来的某个时候在调用响应的处理函数。实现执行代码和处理结果的分离。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> ajax <span class="token operator">=</span> <span class="token function">ajaxGet</span><span class="token punctuation">(</span><span class="token string">'http://...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ajax<span class="token punctuation">.</span><span class="token function">ifSuccess</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">ifFail</span><span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回调地狱：多层回调函数嵌套</p><pre class=" language-js"><code class="language-js"><span class="token function">method1</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> err<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">method2</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> err<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token function">method3</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> err<span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token function">method4</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> err<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token function">method5</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="（2）问题"><a href="#（2）问题" class="headerlink" title="（2）问题"></a>（2）问题</h3><ul><li>难以理解和调试，无法对回调结果进行选择性的操作</li><li>信任问题：回调函数不能保证什么时候去调用回调，以及使用什么方式去调用回调（控制反转）</li></ul><h3 id="（3）解决方案"><a href="#（3）解决方案" class="headerlink" title="（3）解决方案"></a>（3）解决方案</h3><p>Promise是对回调地狱的思考，或者说是改良方案。它是在async函数普及之前唯一的通用性规范，最早是在CommonJs社区被提出来，当时比较被接受的是Promise/A规范。后来在此基础上提出了Promise/A+规范，也就是现在业内推行的规范，ES6也采用这种规范。</p><p>promise这个词意味着”承诺“一个暂时还没有完成但将来会完成的事，与Promise进行交互的最主要的方法是，通过将函数传入它的then函数从而获得Promise的最终结果，告诉下一个then函数如何操作。</p><p>Promise最大的好处是在异步执行的流程中，把<strong>执行代码</strong>和<strong>处理结果</strong>的代码清晰地分离了。</p><h2 id="2、介绍"><a href="#2、介绍" class="headerlink" title="2、介绍"></a>2、介绍</h2><p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。<br>由于 Promise 是 ES6 新增加的，所以一些旧的浏览器并不支持，苹果的 Safari 10 和 Windows 的 Edge 14 版本以上浏览器才开始支持 ES6 特性。</p><p>以下是 Promise 浏览器支持的情况：<br><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/promise%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5.png" alt="promise浏览器支持情况"></p><h2 id="3、构造Promise"><a href="#3、构造Promise" class="headerlink" title="3、构造Promise"></a>3、构造Promise</h2><pre><code>new Promise(function (resolve, reject) {    // do somesthing...});</code></pre><p>示例比较：</p><pre><code>//正常书写setTimeout(function () {    console.log("我");    setTimeout(function () {        console.log("很");        setTimeout(function () {            console.log("帅");        }, 3000);    }, 4000);}, 1000);</code></pre><pre><code>new Promise(function (resolve, reject) {    setTimeout(function () {        console.log("我");        resolve();    }, 1000);}).then(function () {    return new Promise(function (resolve, reject) {        setTimeout(function () {            console.log("很");            resolve();        }, 4000);    });}).then(function () {    setTimeout(function () {        console.log("帅");    }, 3000);});</code></pre><h2 id="4、剖析"><a href="#4、剖析" class="headerlink" title="4、剖析"></a>4、剖析</h2><p>Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject。<br>当 Promise 被构造时，起始函数会被异步执行。<br>resolve 和 reject 都是函数，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的：</p><pre><code>new Promise(function (resolve, reject) {    var a = 0;    var b = 1;    if (b == 0) reject("Diveide zero");    else resolve(a / b);}).then(function (value) {    console.log("a / b = " + value);}).catch(function (err) {    console.log(err);}).finally(function () {    console.log("End");});</code></pre><p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列。</p><pre><code>new Promise(function (resolve, reject) {    console.log(1111);    resolve(2222);}).then(function (value) {    console.log(value);    return 3333;}).then(function (value) {    console.log(value);    throw "An error";}).catch(function (err) {    console.log(err);});</code></pre><p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p><p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p><p>但是请注意以下两点：</p><ul><li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li><li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li></ul><h2 id="5、Promise函数"><a href="#5、Promise函数" class="headerlink" title="5、Promise函数"></a>5、Promise函数</h2><p>上述的 “计时器” 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p><pre><code>function print(delay, message) {    return new Promise(function (resolve, reject) {        setTimeout(function () {            console.log(message);            resolve();        }, delay);    });}</code></pre><p>然后实现功能：</p><pre><code>print(1000, "First").then(function () {    return print(4000, "Second");}).then(function () {    print(3000, "Third");});//异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。async function asyncFunc() {    await print(1000, "First");    await print(4000, "Second");    await print(3000, "Third");}asyncFunc();</code></pre><p>这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。</p><h2 id="6、解惑"><a href="#6、解惑" class="headerlink" title="6、解惑"></a>6、解惑</h2><ul><li>then、catch 和 finally 序列顺序可以颠倒，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。</li><li>then 块如何中断：then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。</li><li>Promise 不是一种将异步转换为同步的方法，Promise 是一种更良好的编程风格。</li><li>Promise 可以用来防范第三方请求多次回调结果，避免不必要的错误产生（例如第三方收费）（控制反转）</li></ul><h2 id="7、promise-A-规范"><a href="#7、promise-A-规范" class="headerlink" title="7、promise/A+规范"></a>7、promise/A+规范</h2><p>其实Promise 规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+。ES6中采用了 Promise/A+ 规范。</p><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><ul><li>一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。</li><li>promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise，then 方法可以被同一个 promise 调用多次。</li><li>Promise/A+并未规范race、all、catch方法，这些是ES6自己规范的。</li></ul><p>参考：<a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4" target="_blank" rel="noopener">Promises/A+规范-翻译</a></p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 先定义三个常量表示状态</span><span class="token keyword">var</span> PENDING <span class="token operator">=</span> <span class="token string">"pending"</span><span class="token punctuation">;</span><span class="token keyword">var</span> FULFILLED <span class="token operator">=</span> <span class="token string">"fulfilled"</span><span class="token punctuation">;</span><span class="token keyword">var</span> REJECTED <span class="token operator">=</span> <span class="token string">"rejected"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> PENDING<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始状态为pending</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化value</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化reason</span>  <span class="token comment" spellcheck="true">// 构造函数里面添加两个数组存储成功和失败的回调</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 存一下this,以便resolve和reject里面访问</span>  <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// resolve方法参数是value</span>  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>      that<span class="token punctuation">.</span>status <span class="token operator">=</span> FULFILLED<span class="token punctuation">;</span>      that<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// resolve里面将所有成功的回调拿出来执行</span>      that<span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">callback</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// reject方法参数是reason</span>  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>      that<span class="token punctuation">.</span>status <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>      that<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// resolve里面将所有失败的回调拿出来执行</span>      that<span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">callback</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span>  <span class="token comment" spellcheck="true">// 这是为了防止死循环</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>      <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"The promise and the return value are the same"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 x 为 Promise ，则使 promise 接受 x 的状态</span>    <span class="token comment" spellcheck="true">// 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y</span>    <span class="token comment" spellcheck="true">// 这个if跟下面判断then然后拿到执行其实重复了，可有可无</span>    x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 如果 x 为对象或者函数</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 把 x.then 赋值给 then</span>      <span class="token keyword">var</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span>      <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果 then 是函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> called <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将 x 作为函数的作用域 this 调用之</span>      <span class="token comment" spellcheck="true">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</span>      <span class="token comment" spellcheck="true">// 名字重名了，我直接用匿名函数了</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>          x<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span>          <span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 resolvePromise 和 rejectPromise 均被调用，</span>            <span class="token comment" spellcheck="true">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span>            <span class="token comment" spellcheck="true">// 实现这条需要前面加一个变量called</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span>          <span class="token keyword">function</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果调用 then 方法抛出了异常 e：</span>        <span class="token comment" spellcheck="true">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 否则以 e 为据因拒绝 promise</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果 then 不是函数，以 x 为参数执行 promise</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>MyPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果onFulfilled不是函数，给一个默认函数，返回value</span>  <span class="token comment" spellcheck="true">// 后面返回新promise的时候也做了onFulfilled的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观</span>  <span class="token keyword">var</span> realOnFulfilled <span class="token operator">=</span> onFulfilled<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> realOnFulfilled <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    realOnFulfilled <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 如果onRejected不是函数，给一个默认函数，返回reason的Error</span>  <span class="token comment" spellcheck="true">// 后面返回新promise的时候也做了onRejected的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观</span>  <span class="token keyword">var</span> realOnRejected <span class="token operator">=</span> onRejected<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> realOnRejected <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    realOnRejected <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> reason<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存一下this</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">realOnFulfilled</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">realOnRejected</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 如果还是PENDING状态，将回调保存下来</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>      that<span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token function">resolve</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">realOnFulfilled</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      that<span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token function">reject</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">realOnRejected</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>deferred <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  result<span class="token punctuation">.</span>promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    result<span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>    result<span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>resolve <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>parameter<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>parameter <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> parameter<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>reject <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>all <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>promiseList<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> resPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> length <span class="token operator">=</span> promiseList<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    promiseList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>promise<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>      MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>        <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>          result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> resPromise<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>race <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>promiseList<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> resPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> length <span class="token operator">=</span> promiseList<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promiseList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>          <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> resPromise<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> error<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MyPromise<span class="token punctuation">.</span>allSettled <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>promiseList<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> length <span class="token operator">=</span> promiseList<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">var</span> currentPromise <span class="token operator">=</span> MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promiseList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          currentPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>            <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>              count<span class="token operator">++</span><span class="token punctuation">;</span>              result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>                status<span class="token punctuation">:</span> <span class="token string">"fulfilled"</span><span class="token punctuation">,</span>                value<span class="token punctuation">:</span> value<span class="token punctuation">,</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>              count<span class="token operator">++</span><span class="token punctuation">;</span>              result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>                status<span class="token punctuation">:</span> <span class="token string">"rejected"</span><span class="token punctuation">,</span>                reason<span class="token punctuation">:</span> reason<span class="token punctuation">,</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> MyPromise<span class="token punctuation">;</span></code></pre><h1 id="三、Event-loop"><a href="#三、Event-loop" class="headerlink" title="三、Event loop"></a>三、Event loop</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><h3 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h3><p>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。</p><ul><li>浏览器的Event Loop是在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">html5的规范</a>中明确定义。</li><li>NodeJS的Event Loop是基于libuv实现的。可以参考Node的<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">官方文档</a>以及libuv的<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方文档</a>。</li><li>libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。<h3 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h3>JavaScript语言就采用event loop，来解决单线程运行带来的一些问题。如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/2013102001.png" alt=""></p><p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/2013102004.png" alt=""></p><p>每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。</p><p>可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”异步模式”（asynchronous I/O)。</p><p>这种机制与android的handler机制类似，如图(仅供参考)：</p><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/20201013100705.png" alt=""></p><h2 id="2、宏队列和微队列"><a href="#2、宏队列和微队列" class="headerlink" title="2、宏队列和微队列"></a>2、宏队列和微队列</h2><p>宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node独有)</li><li>requestAnimationFrame (浏览器独有)</li><li>I/O</li><li>UI rendering (浏览器独有)<br>微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</li><li>process.nextTick (Node独有)</li><li>Promise</li><li>Object.observe</li><li>MutationObserver<br>（注：这里只针对浏览器和NodeJS）</li></ul><h2 id="3、浏览器的Event-Loop"><a href="#3、浏览器的Event-Loop" class="headerlink" title="3、浏览器的Event Loop"></a>3、浏览器的Event Loop</h2><h3 id="（1）图解："><a href="#（1）图解：" class="headerlink" title="（1）图解："></a>（1）图解：</h3><p><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84Eventloop.png" alt="浏览器的Eventloop"></p><h3 id="（2）执行一个JavaScript代码的具体流程："><a href="#（2）执行一个JavaScript代码的具体流程：" class="headerlink" title="（2）执行一个JavaScript代码的具体流程："></a>（2）执行一个JavaScript代码的具体流程：</h3><ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li><li>全局Script代码执行完毕后，调用栈Stack会清空；</li><li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li><li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</li><li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li><li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li><li>执行完毕后，调用栈Stack为空；</li><li>重复第3-7个步骤；</li><li>重复第3-7个步骤；<br>……</li></ol><h3 id="（3）归纳3个重点："><a href="#（3）归纳3个重点：" class="headerlink" title="（3）归纳3个重点："></a>（3）归纳3个重点：</h3><ol><li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li><li>微任务队列中所有的任务都会被依次取出来执行，直到microtask queue为空；</li><li>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。</li></ol><h3 id="（4）示例代码"><a href="#（4）示例代码" class="headerlink" title="（4）示例代码"></a>（4）示例代码</h3><pre><code>console.log(1);setTimeout(() =&gt; {  console.log(2);  Promise.resolve().then(() =&gt; {    console.log(3)  });});new Promise((resolve, reject) =&gt; {  console.log(4)  resolve(5)}).then((data) =&gt; {  console.log(data);})setTimeout(() =&gt; {  console.log(6);})console.log(7);</code></pre><p>结果输出：</p><pre><code>// 正确答案1475236</code></pre><h3 id="（5）练习（巩固）"><a href="#（5）练习（巩固）" class="headerlink" title="（5）练习（巩固）"></a>（5）练习（巩固）</h3><pre><code>console.log(1);setTimeout(() =&gt; {  console.log(2);  Promise.resolve().then(() =&gt; {    console.log(3)  });});new Promise((resolve, reject) =&gt; {  console.log(4)  resolve(5)}).then((data) =&gt; {  console.log(data);  Promise.resolve().then(() =&gt; {    console.log(6)  }).then(() =&gt; {    console.log(7)    setTimeout(() =&gt; {      console.log(8)    }, 0);  });})setTimeout(() =&gt; {  console.log(9);})console.log(10);// 正确答案14105672398</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.runoob.com/js/js-async.html" target="_blank" rel="noopener">JavaScript 异步编程</a></li><li><a href="https://www.runoob.com/js/js-promise.html" target="_blank" rel="noopener">JavaScript Promise</a></li><li><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备-二</title>
      <link href="/posts/7dc8.html"/>
      <url>/posts/7dc8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h2><p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</p><h2 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h2><pre><code>var test = {    a : 10,    b : {        a : 12,        fn : function(){            console.log(this.a); //12        }    }}test.b.fn();</code></pre><h2 id="3、解读"><a href="#3、解读" class="headerlink" title="3、解读"></a>3、解读</h2><p>这里同样也是对象test点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确</p><ul><li><p>情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window（undefined），但是我们这里不探讨严格版的问题。</p></li><li><p>情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p></li><li><p>情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p></li></ul><h2 id="4、例题解析"><a href="#4、例题解析" class="headerlink" title="4、例题解析"></a>4、例题解析</h2><pre><code>var test = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = test.b.fn;j();</code></pre><p>this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window。</p><h2 id="5、当this遇到return"><a href="#5、当this遇到return" class="headerlink" title="5、当this遇到return"></a>5、当this遇到return</h2><pre><code>function fn()  {      this.user = '蜡笔小清新';      return function(){};}var a = new fn;  console.log(a.user); //undefined</code></pre><pre><code>function fn()  {      this.user = '蜡笔小清新';      return 1;}var a = new fn;  console.log(a.user); //蜡笔小清新</code></pre><p>如果返回值是一个对象（除了null,undefined），那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p><h1 id="二、call-apply"><a href="#二、call-apply" class="headerlink" title="二、call/apply"></a>二、call/apply</h1><h2 id="1、说明-1"><a href="#1、说明-1" class="headerlink" title="1、说明"></a>1、说明</h2><ul><li>两者都可以改变this指向<pre><code>var a = {  user:"蜡笔小清新",  fn:function(){      console.log(this.user); //蜡笔小清新  }}var b = a.fn;b.call(a);</code></pre></li><li>任何一个方法都可以.call，其实方法的执行就是方法.call 执行，例如test() 就相当于 test.call()<pre><code>function test() {console.log(’蜡笔小清新‘); //蜡笔小清新}test.call();</code></pre><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><pre><code>function Person(name,age) {this.name = name;this.age = age; }var obj = {};Person.call(obj);</code></pre></li><li>call 后边的括号里是可以传东西的，比如传一个 obj 进去，他就会引导着 Person 发生 很大的变化。如果在 Person 底下 new 的话，this 就代表了构造函数所 产生的对象，我们假如说没有new的话，this默认是指向window的，但是我们在call 里传 obj 了，那么这个 this 就不是默认的了，就变成 obj 了，就是 call 里边传谁进 去，this 就是谁。等于说里边现在执行的时候就是 obj.name = name，obj.age = age， 即使是这样，依然可以传参:<br>Person.call(obj,’小万’,20);<br>现在访问 obj 就得到{name: “小万”, age: 20},因为 call 括号里的第一位会改变 this 指向，第一位以后都会当成正常的实参传到形参里边去（null就指向window），所以这里边第二个实参对应 的是函数执行的第一位形参，第三个实参对应的是函数执行的第二位形参。所以 call 的根本原因是改变 this 指向，借用 Person 的执行封装了 obj，借用你的方法来实现我 的功能。<h2 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h2></li></ul><pre><code>function Wheel(wheelSize, style) {    this.wheelSize = wheelSize;    this.style = style;}function Sit(c, sitColor) {    this.c = c;    this.sitColor = sitColor;}function Model(height, width, len) {    this.height = height;    this.width = width;    this.len = len;}function Car(wheelSize, style, c, sitColor, height, width, len) {    Wheel.call(this, wheelSize, style);    Sit.call(this, c, sitColor);    Model.call(this, height, width, len);}var car = new Car(100, "魂动之恶魔之眼", "织物", "white", 1800, 1900, 4900);</code></pre><h2 id="4、apply"><a href="#4、apply" class="headerlink" title="4、apply"></a>4、apply</h2><ul><li>call 和 apply 基本上是一样的，只是写法不一样，call 需要把实参一个个传进去，但 是 apply 只能传一个值 arguments，即实参列表</li></ul><pre><code>function Person(name, age, sex) {    this.name = name;    this.age = age;    this.sex = sex;}function Student(name, age, sex, tel, grade) {    Person.apply(this, [name, age, sex]);    this.tel = tel;    this.grade = grade;}var student = new Student('小万', 20, 'male', 187, 2017);</code></pre><h1 id="三、bind"><a href="#三、bind" class="headerlink" title="三、bind"></a>三、bind</h1><h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><ul><li>bind和call、apply方法不同，实际上bind方法返回的是一个修改过后的函数。(可以通过call和apply方法来实现bind)</li></ul><pre><code>var a = {    user:"蜡笔小清新",    fn:function(){        console.log(this.user); //蜡笔小清新    }}var b = a.fn;var c = b.bind(a);c();</code></pre><h2 id="2、传参"><a href="#2、传参" class="headerlink" title="2、传参"></a>2、传参</h2><ul><li>同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。如果传值是对象，返回的是对象的实例。</li></ul><pre><code>var a = {    user:"蜡笔小清新",    fn:function(e,d,f){        console.log(this.user); //蜡笔小清新        console.log(e,d,f); //10 1 2    }}var b = a.fn;var c = b.bind(a,10);c(1,2);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备-一</title>
      <link href="/posts/323b.html"/>
      <url>/posts/323b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、预编译"><a href="#一、预编译" class="headerlink" title="一、预编译"></a>一、预编译</h1><h2 id="1、预编译前奏"><a href="#1、预编译前奏" class="headerlink" title="1、预编译前奏"></a>1、预编译前奏</h2><p>JavaScript执行三部曲：我们知道，JS是解释性语言，解释一行执行一行，但是在解释执行之前，他会进行两个过程，语法分析和预编译，语法分析就是他会把正片JS代码扫描一遍，看看有没有语法错误，接下来进行的就预编译。预编译结束之后才是解释一行执行一行。<br>我们可以先看几个例子：<br>(1)</p><pre><code>test();function test(){  console.log('a');}</code></pre><p>无论test()写在上面还是下面都会执行<br>(2)</p><pre><code>console.log(a);var a = 123;</code></pre><p>总结（片面）：函数声明整体提升，变量    声明提升。<br>(3)</p><pre><code>console.log(a)function a(a){   var a = 234;   var a = function (){ }   a();}var a = 123;</code></pre><p>这个时候 a 得啥?函数是 a，变量是 a，形参也是 a，而且不会报错，那么输出得啥? 这就是那两句话解决不了的,预编译的环节则可以解答这些疑惑。<br>(4)</p><pre><code>function test(){   var a = b = 123;}test();</code></pre><ul><li>一切声明的全局变量，全是 window 属性。</li><li>imply global 暗示全局变量:即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。<h2 id="2、函数预编译"><a href="#2、函数预编译" class="headerlink" title="2、函数预编译"></a>2、函数预编译</h2><h3 id="预编译四部曲"><a href="#预编译四部曲" class="headerlink" title="预编译四部曲"></a>预编译四部曲</h3></li><li>第一步:创建 AO 对象。</li><li>第二步:找形参和变量声明，将变量和形参名作为 AO 的属性名，值为 undefined。 </li><li>第三步:将实参值与形参统一。</li><li>第四步:在函数体里找函数声明，值赋予函数体。<pre><code>function fn(a){console.log(a); var a = 123;console.log(a);function a(){  };console.log(a);var b = function (){  };console.log(b);function d(){  };}fn(1);</code></pre>解析：<br>预编译过程：<br>AO{<br>  a:undefined,<br>  b:undefined<br>}<br>AO{<br>  a:1,<br>  b:undefined<br>}<br>AO{<br>  a:function a(){},<br>  b:undefined,<br>  d:function d(){}<br>}<br>执行：function a(){}    123   123    function(){}<h2 id="3、全局预编译"><a href="#3、全局预编译" class="headerlink" title="3、全局预编译"></a>3、全局预编译</h2><h3 id="全局的预编译和函数里的预编译一样，只不过少了几个步骤"><a href="#全局的预编译和函数里的预编译一样，只不过少了几个步骤" class="headerlink" title="全局的预编译和函数里的预编译一样，只不过少了几个步骤:"></a>全局的预编译和函数里的预编译一样，只不过少了几个步骤:</h3></li><li>第一步:创建 GO 对象。(GO 对象就是 Global Object，是全局的执行期上下文，换了 个名，其实和 AO 是一样的)</li><li>第二步:找变量声明，将变量名作为 GO 的属性名，值为 undefined。 第三步:找函数声明，值赋予函数体。<h1 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h1><h2 id="1、执行期上下文（AO）"><a href="#1、执行期上下文（AO）" class="headerlink" title="1、执行期上下文（AO）"></a>1、执行期上下文（AO）</h2>当函数执行的前一刻，会创建一个称为 执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每 次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多 个执行期上下文，当函数执行完毕，他创建的执行期上下文被销毁。<h2 id="2、-scope"><a href="#2、-scope" class="headerlink" title="2、[[scope]]"></a>2、[[scope]]</h2>每个 JavaScript 函数都是一个对象，对象中有些属性我们可以访 问，但有些不可以，这些属性仅供 JavaScript 引擎存取，[[scope]]就是其中一个， [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。<h2 id="3、作用域链"><a href="#3、作用域链" class="headerlink" title="3、作用域链"></a>3、作用域链</h2>[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链 接，我们把这种链式链接叫做作用域链。在哪个函数里边查找变量，就去哪个函数的 作用域链顶端依次向下查找。<br>举例：<pre><code>function a(){  function b(){      function c(){          }      c();   }  b();}a();解析:a 函数被定义:a. [[scope]]-------&gt;0:GOa 函数执行前:a. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数被定义:b. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数执行前:b. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数被定义:c. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数执行前:c. [[scope]]-------&gt;0:c 的 AO                             1:b的AO                              2:a的AO 3:GO</code></pre><h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2>当内部函数被保存到外部时，就会生成闭包，闭包会导致原有作用域链不释放，造成 内存泄露。<br>举例：<pre><code>function a(){  function b(){      var bbb = 234;      console.log(aaa);   }  var aaa = 123;  return b; }var glob = 100;var demo = a();demo();</code></pre><img src="https://cdn.jsdelivr.net/gh/wanzhr/imgs/images/%E9%97%AD%E5%8C%85%E5%9B%BE%E8%A7%A3.png" alt="闭包图解"></li></ul><h3 id="（1）实现公有变量，比如函数累加器"><a href="#（1）实现公有变量，比如函数累加器" class="headerlink" title="（1）实现公有变量，比如函数累加器:"></a>（1）实现公有变量，比如函数累加器:</h3><pre><code>function add(){     var count = 0;    function demo(){        count ++;        console.log(count);        }    return demo;}var counter = add();counter();counter();counter();</code></pre><h3 id="（2）可以做缓存（存储结构）"><a href="#（2）可以做缓存（存储结构）" class="headerlink" title="（2）可以做缓存（存储结构）"></a>（2）可以做缓存（存储结构）</h3><pre><code>function eater(){       var food = "";      var obj = {             eat:function (){                 console.log("I am eating " + food);                 food = "";             },            push:function (myFood){                 food = myFood;            }       }      return obj;  }var eater1 = eater();eater1.push("banana");eater1.eat();</code></pre><h3 id="（3）可以实现封装，属性私有化"><a href="#（3）可以实现封装，属性私有化" class="headerlink" title="（3）可以实现封装，属性私有化"></a>（3）可以实现封装，属性私有化</h3><h3 id="（4）模块化开发，防止污染全局变量"><a href="#（4）模块化开发，防止污染全局变量" class="headerlink" title="（4）模块化开发，防止污染全局变量"></a>（4）模块化开发，防止污染全局变量</h3><h1 id="三、立即执行函数"><a href="#三、立即执行函数" class="headerlink" title="三、立即执行函数"></a>三、立即执行函数</h1><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>JS 给我们提供了一类函数，叫立即执行函数，这种函数执行完 马上就释放了，是针对初始化功能的函数，不占用内存空间。</p><h3 id="（1）形式"><a href="#（1）形式" class="headerlink" title="（1）形式"></a>（1）形式</h3><pre><code>(function (){}())</code></pre><p>可以添加参数</p><pre><code>(function (a,b){    console.log(a+b);}(1,2))</code></pre><p>同样也是有返回值的</p><pre><code>var num = (function (a,b){         var d = a + b;        return d; }(1,2))</code></pre><h3 id="（2）写法"><a href="#（2）写法" class="headerlink" title="（2）写法"></a>（2）写法</h3><pre><code>第一种：(function (){}())        W3C组织建议第二种：(function (){})() </code></pre><h3 id="（3）拓展：只有表达式才能被符号执行"><a href="#（3）拓展：只有表达式才能被符号执行" class="headerlink" title="（3）拓展：只有表达式才能被符号执行"></a>（3）拓展：只有表达式才能被符号执行</h3><p>举例：</p><pre><code>function test(){      console.log(1);}()//报错</code></pre><pre><code>var test= function (){      console.log(1);}()//执行</code></pre><pre><code>+ function test(){      console.log(1);}()</code></pre><p>本来他是函数声明，但是你在前边加上正号他就理论上转换为数字了，那他就是一个 表达式，你再后边直接加()就会执行，变成立即执行函数，然后忽略函数名，你执行 完后输出 test 就会报错，当然前边加上-或者!都可以，&amp;&amp;和||也可以，不过两边都要有东西，但是*和/不行，这里的+-代表正负号。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first article</title>
      <link href="/posts/bd8.html"/>
      <url>/posts/bd8.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><h3 id="Post-new-articles"><a href="#Post-new-articles" class="headerlink" title="Post new articles"></a>Post new articles</h3><pre class=" language-bash"><code class="language-bash">$  hexo cl <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo d </code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
