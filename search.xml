<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS基础知识储备（二）</title>
      <link href="/posts/7dc8.html"/>
      <url>/posts/7dc8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h2><p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</p><h2 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h2><pre><code>var test = {    a : 10,    b : {        a : 12,        fn : function(){            console.log(this.a); //12        }    }}test.b.fn();</code></pre><h2 id="3、解读"><a href="#3、解读" class="headerlink" title="3、解读"></a>3、解读</h2><p>这里同样也是对象test点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确</p><ul><li><p>情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window（undefined），但是我们这里不探讨严格版的问题。</p></li><li><p>情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p></li><li><p>情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p></li></ul><h2 id="4、例题解析"><a href="#4、例题解析" class="headerlink" title="4、例题解析"></a>4、例题解析</h2><pre><code>var test = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = test.b.fn;j();</code></pre><p>this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window。</p><h2 id="5、当this遇到return"><a href="#5、当this遇到return" class="headerlink" title="5、当this遇到return"></a>5、当this遇到return</h2><pre><code>function fn()  {      this.user = '蜡笔小清新';      return function(){};}var a = new fn;  console.log(a.user); //undefined</code></pre><pre><code>function fn()  {      this.user = '蜡笔小清新';      return 1;}var a = new fn;  console.log(a.user); //蜡笔小清新</code></pre><p>如果返回值是一个对象（除了null），那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p><h1 id="二、call-apply"><a href="#二、call-apply" class="headerlink" title="二、call/apply"></a>二、call/apply</h1><h2 id="1、说明-1"><a href="#1、说明-1" class="headerlink" title="1、说明"></a>1、说明</h2><ul><li>两者都可以改变this指向<pre><code>var a = {  user:"蜡笔小清新",  fn:function(){      console.log(this.user); //蜡笔小清新  }}var b = a.fn;b.call(a);</code></pre></li><li>任何一个方法都可以.call，其实方法的执行就是方法.call 执行，例如test() 就相当于 test.call()<pre><code>function test() {console.log(’蜡笔小清新‘); //蜡笔小清新}test.call();</code></pre><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><pre><code>function Person(name,age) {this.name = name;this.age = age; }var obj = {};Person.call(obj);</code></pre></li><li>call 后边的括号里是可以传东西的，比如传一个 obj 进去，他就会引导着 Person 发生 很大的变化。如果在 Person 底下 new 的话，this 就代表了构造函数所 产生的对象，我们假如说没有new的话，this默认是指向window的，但是我们在call 里传 obj 了，那么这个 this 就不是默认的了，就变成 obj 了，就是 call 里边传谁进 去，this 就是谁。等于说里边现在执行的时候就是 obj.name = name，obj.age = age， 即使是这样，依然可以传参:<br>Person.call(obj,’小万’,20);<br>现在访问 obj 就得到{name: “小万”, age: 20},因为 call 括号里的第一位会改变 this 指向，第一位以后都会当成正常的实参传到形参里边去（null就指向window），所以这里边第二个实参对应 的是函数执行的第一位形参，第三个实参对应的是函数执行的第二位形参。所以 call 的根本原因是改变 this 指向，借用 Person 的执行封装了 obj，借用你的方法来实现我 的功能。<h2 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h2></li></ul><pre><code>function Wheel(wheelSize, style) {    this.wheelSize = wheelSize;    this.style = style;}function Sit(c, sitColor) {    this.c = c;    this.sitColor = sitColor;}function Model(height, width, len) {    this.height = height;    this.width = width;    this.len = len;}function Car(wheelSize, style, c, sitColor, height, width, len) {    Wheel.call(this, wheelSize, style);    Sit.call(this, c, sitColor);    Model.call(this, height, width, len);}var car = new Car(100, "魂动之恶魔之眼", "织物", "white", 1800, 1900, 4900);</code></pre><h2 id="4、apply"><a href="#4、apply" class="headerlink" title="4、apply"></a>4、apply</h2><ul><li>call 和 apply 基本上是一样的，只是写法不一样，call 需要把实参一个个传进去，但 是 apply 只能传一个值 arguments，即实参列表</li></ul><pre><code>function Person(name, age, sex) {    this.name = name;    this.age = age;    this.sex = sex;}function Student(name, age, sex, tel, grade) {    Person.apply(this, [name, age, sex]);    this.tel = tel;    this.grade = grade;}var student = new Student('小万', 20, 'male', 187, 2017);</code></pre><h1 id="三、bind"><a href="#三、bind" class="headerlink" title="三、bind"></a>三、bind</h1><h2 id="1、-bind和call、apply方法不同，实际上bind方法返回的是一个修改过后的函数。"><a href="#1、-bind和call、apply方法不同，实际上bind方法返回的是一个修改过后的函数。" class="headerlink" title="1、 bind和call、apply方法不同，实际上bind方法返回的是一个修改过后的函数。"></a>1、 bind和call、apply方法不同，实际上bind方法返回的是一个修改过后的函数。</h2><pre><code>var a = {    user:"蜡笔小清新",    fn:function(){        console.log(this.user); //蜡笔小清新    }}var b = a.fn;var c = b.bind(a);c();</code></pre><h2 id="2、同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。"><a href="#2、同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。" class="headerlink" title="2、同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。"></a>2、同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。</h2><pre><code>var a = {    user:"蜡笔小清新",    fn:function(e,d,f){        console.log(this.user); //蜡笔小清新        console.log(e,d,f); //10 1 2    }}var b = a.fn;var c = b.bind(a,10);c(1,2);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识储备(一)</title>
      <link href="/posts/323b.html"/>
      <url>/posts/323b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、预编译"><a href="#一、预编译" class="headerlink" title="一、预编译"></a>一、预编译</h1><h2 id="1、预编译前奏"><a href="#1、预编译前奏" class="headerlink" title="1、预编译前奏"></a>1、预编译前奏</h2><p>JavaScript执行三部曲：我们知道，JS是解释性语言，解释一行执行一行，但是在解释执行之前，他会进行两个过程，语法分析和预编译，语法分析就是他会把正片JS代码扫描一遍，看看有没有语法错误，接下来进行的就预编译。预编译结束之后才是解释一行执行一行。<br>我们可以先看几个例子：<br>(1)</p><pre><code>test();function test(){  console.log('a');}</code></pre><p>无论test()写在上面还是下面都会执行<br>(2)</p><pre><code>console.log(a);var a = 123;</code></pre><p>总结（片面）：函数声明整体提升，变量    声明提升。<br>(3)</p><pre><code>console.log(a)function a(a){   var a = 234;   var a = function (){ }   a();}var a = 123;</code></pre><p>这个时候 a 得啥?函数是 a，变量是 a，形参也是 a，而且不会报错，那么输出得啥? 这就是那两句话解决不了的,预编译的环节则可以解答这些疑惑。<br>(4)</p><pre><code>function test(){   var a = b = 123;}test();</code></pre><ul><li>一切声明的全局变量，全是 window 属性。</li><li>imply global 暗示全局变量:即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。<h2 id="2、函数预编译"><a href="#2、函数预编译" class="headerlink" title="2、函数预编译"></a>2、函数预编译</h2><h3 id="预编译四部曲"><a href="#预编译四部曲" class="headerlink" title="预编译四部曲"></a>预编译四部曲</h3></li><li>第一步:创建 AO 对象。</li><li>第二步:找形参和变量声明，将变量和形参名作为 AO 的属性名，值为 undefined。 </li><li>第三步:将实参值与形参统一。</li><li>第四步:在函数体里找函数声明，值赋予函数体。<pre><code>function fn(a){console.log(a); var a = 123;console.log(a);function a(){  };console.log(a);var b = function (){  };console.log(b);function d(){  };}fn(1);</code></pre>解析：<br>预编译过程：<br>AO{<br>  a:undefined,<br>  b:undefined<br>}<br>AO{<br>  a:1,<br>  b:undefined<br>}<br>AO{<br>  a:function a(){},<br>  b:undefined,<br>  d:function d(){}<br>}<br>执行：function a(){}    123   123    function(){}<h2 id="3、全局预编译"><a href="#3、全局预编译" class="headerlink" title="3、全局预编译"></a>3、全局预编译</h2><h3 id="全局的预编译和函数里的预编译一样，只不过少了几个步骤"><a href="#全局的预编译和函数里的预编译一样，只不过少了几个步骤" class="headerlink" title="全局的预编译和函数里的预编译一样，只不过少了几个步骤:"></a>全局的预编译和函数里的预编译一样，只不过少了几个步骤:</h3></li><li>第一步:创建 GO 对象。(GO 对象就是 Global Object，是全局的执行期上下文，换了 个名，其实和 AO 是一样的)</li><li>第二步:找变量声明，将变量名作为 GO 的属性名，值为 undefined。 第三步:找函数声明，值赋予函数体。<h1 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h1><h2 id="1、执行期上下文（AO）"><a href="#1、执行期上下文（AO）" class="headerlink" title="1、执行期上下文（AO）"></a>1、执行期上下文（AO）</h2>当函数执行的前一刻，会创建一个称为 执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每 次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多 个执行期上下文，当函数执行完毕，他创建的执行期上下文被销毁。<h2 id="2、-scope"><a href="#2、-scope" class="headerlink" title="2、[[scope]]"></a>2、[[scope]]</h2>每个 JavaScript 函数都是一个对象，对象中有些属性我们可以访 问，但有些不可以，这些属性仅供 JavaScript 引擎存取，[[scope]]就是其中一个， [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。<h2 id="3、作用域链"><a href="#3、作用域链" class="headerlink" title="3、作用域链"></a>3、作用域链</h2>[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链 接，我们把这种链式链接叫做作用域链。在哪个函数里边查找变量，就去哪个函数的 作用域链顶端依次向下查找。<br>举例：<pre><code>function a(){  function b(){      function c(){          }      c();   }  b();}a();解析:a 函数被定义:a. [[scope]]-------&gt;0:GOa 函数执行前:a. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数被定义:b. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数执行前:b. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数被定义:c. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数执行前:c. [[scope]]-------&gt;0:c 的 AO                             1:b的AO                              2:a的AO 3:GO</code></pre><h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2>当内部函数被保存到外部时，就会生成闭包，闭包会导致原有作用域链不释放，造成 内存泄露。<br>举例：<pre><code>function a(){  function b(){      var bbb = 234;      console.log(aaa);   }  var aaa = 123;  return b; }var glob = 100;var demo = a();demo();</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://upload-images.jianshu.io/upload_images/13449852-7c9bd07540d3e4e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20200726-104858@2x.png"></li></ul><h3 id="（1）实现公有变量，比如函数累加器"><a href="#（1）实现公有变量，比如函数累加器" class="headerlink" title="（1）实现公有变量，比如函数累加器:"></a>（1）实现公有变量，比如函数累加器:</h3><pre><code>function add(){     var count = 0;    function demo(){        count ++;        console.log(count);        }    return demo;}var counter = add();counter();counter();counter();</code></pre><h3 id="（2）可以做缓存（存储结构）"><a href="#（2）可以做缓存（存储结构）" class="headerlink" title="（2）可以做缓存（存储结构）"></a>（2）可以做缓存（存储结构）</h3><pre><code>function eater(){       var food = "";      var obj = {             eat:function (){                 console.log("I am eating " + food);                 food = "";             },            push:function (myFood){                 food = myFood;            }       }      return obj;  }var eater1 = eater();eater1.push("banana");eater1.eat();</code></pre><h3 id="（3）可以实现封装，属性私有化"><a href="#（3）可以实现封装，属性私有化" class="headerlink" title="（3）可以实现封装，属性私有化"></a>（3）可以实现封装，属性私有化</h3><h3 id="（4）模块化开发，防止污染全局变量"><a href="#（4）模块化开发，防止污染全局变量" class="headerlink" title="（4）模块化开发，防止污染全局变量"></a>（4）模块化开发，防止污染全局变量</h3><h1 id="三、立即执行函数"><a href="#三、立即执行函数" class="headerlink" title="三、立即执行函数"></a>三、立即执行函数</h1><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>JS 给我们提供了一类函数，叫立即执行函数，这种函数执行完 马上就释放了，是针对初始化功能的函数，不占用内存空间。</p><h3 id="（1）形式"><a href="#（1）形式" class="headerlink" title="（1）形式"></a>（1）形式</h3><pre><code>(function (){}())</code></pre><p>可以添加参数</p><pre><code>(function (a,b){    console.log(a+b);}(1,2))</code></pre><p>同样也是有返回值的</p><pre><code>var num = (function (a,b){         var d = a + b;        return d; }(1,2))</code></pre><h3 id="（2）写法"><a href="#（2）写法" class="headerlink" title="（2）写法"></a>（2）写法</h3><pre><code>第一种：(function (){}())        W3C组织建议第二种：(function (){})() </code></pre><h3 id="（3）拓展：只有表达式才能被符号执行"><a href="#（3）拓展：只有表达式才能被符号执行" class="headerlink" title="（3）拓展：只有表达式才能被符号执行"></a>（3）拓展：只有表达式才能被符号执行</h3><p>举例：</p><pre><code>function test(){      console.log(1);}()//报错</code></pre><pre><code>var test= function (){      console.log(1);}()//执行</code></pre><pre><code>+ function test(){      console.log(1);}()</code></pre><p>本来他是函数声明，但是你在前边加上正号他就理论上转换为数字了，那他就是一个 表达式，你再后边直接加()就会执行，变成立即执行函数，然后忽略函数名，你执行 完后输出 test 就会报错，当然前边加上-或者!都可以，&amp;&amp;和||也可以，不过两边都要有东西，但是*和/不行，这里的+-代表正负号。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first article</title>
      <link href="/posts/bd8.html"/>
      <url>/posts/bd8.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><h3 id="Post-new-articles"><a href="#Post-new-articles" class="headerlink" title="Post new articles"></a>Post new articles</h3><pre class=" language-bash"><code class="language-bash">$  hexo cl <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo d </code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
