<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS基础知识储备(一)</title>
      <link href="/posts/323b.html"/>
      <url>/posts/323b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、预编译"><a href="#一、预编译" class="headerlink" title="一、预编译"></a>一、预编译</h1><h2 id="1、预编译前奏"><a href="#1、预编译前奏" class="headerlink" title="1、预编译前奏"></a>1、预编译前奏</h2><p>JavaScript执行三部曲：我们知道，JS是解释性语言，解释一行执行一行，但是在解释执行之前，他会进行两个过程，语法分析和预编译，语法分析就是他会把正片JS代码扫描一遍，看看有没有语法错误，接下来进行的就预编译。预编译结束之后才是解释一行执行一行。<br>我们可以先看几个例子：<br>(1)</p><pre><code>test();function test(){  console.log('a');}</code></pre><p>无论test()写在上面还是下面都会执行<br>(2)</p><pre><code>console.log(a);var a = 123;</code></pre><p>总结（片面）：函数声明整体提升，变量    声明提升。<br>(3)</p><pre><code>console.log(a)function a(a){   var a = 234;   var a = function (){ }   a();}var a = 123;</code></pre><p>这个时候 a 得啥?函数是 a，变量是 a，形参也是 a，而且不会报错，那么输出得啥? 这就是那两句话解决不了的,预编译的环节则可以解答这些疑惑。<br>(4)</p><pre><code>function test(){   var a = b = 123;}test();</code></pre><ul><li>一切声明的全局变量，全是 window 属性。</li><li>imply global 暗示全局变量:即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。<h2 id="2、函数预编译"><a href="#2、函数预编译" class="headerlink" title="2、函数预编译"></a>2、函数预编译</h2><h3 id="预编译四部曲"><a href="#预编译四部曲" class="headerlink" title="预编译四部曲"></a>预编译四部曲</h3></li><li>第一步:创建 AO 对象。</li><li>第二步:找形参和变量声明，将变量和形参名作为 AO 的属性名，值为 undefined。 </li><li>第三步:将实参值与形参统一。</li><li>第四步:在函数体里找函数声明，值赋予函数体。<pre><code>function fn(a){console.log(a); var a = 123;console.log(a);function a(){  };console.log(a);var b = function (){  };console.log(b);function d(){  };}fn(1);</code></pre>解析：<br>预编译过程：<br>AO{<br>  a:undefined,<br>  b:undefined<br>}<br>AO{<br>  a:1,<br>  b:undefined<br>}<br>AO{<br>  a:function a(){},<br>  b:undefined,<br>  d:function d(){}<br>}<br>执行：function a(){}    123   123    function(){}<h2 id="3、全局预编译"><a href="#3、全局预编译" class="headerlink" title="3、全局预编译"></a>3、全局预编译</h2>###全局的预编译和函数里的预编译一样，只不过少了几个步骤:</li><li>第一步:创建 GO 对象。(GO 对象就是 Global Object，是全局的执行期上下文，换了 个名，其实和 AO 是一样的)</li><li>第二步:找变量声明，将变量名作为 GO 的属性名，值为 undefined。 第三步:找函数声明，值赋予函数体。<h1 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h1><h2 id="1、执行期上下文（AO）"><a href="#1、执行期上下文（AO）" class="headerlink" title="1、执行期上下文（AO）"></a>1、执行期上下文（AO）</h2>当函数执行的前一刻，会创建一个称为 执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每 次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多 个执行期上下文，当函数执行完毕，他创建的执行期上下文被销毁。<h2 id="2、-scope"><a href="#2、-scope" class="headerlink" title="2、[[scope]]"></a>2、[[scope]]</h2>每个 JavaScript 函数都是一个对象，对象中有些属性我们可以访 问，但有些不可以，这些属性仅供 JavaScript 引擎存取，[[scope]]就是其中一个， [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。<h2 id="3、作用域链"><a href="#3、作用域链" class="headerlink" title="3、作用域链"></a>3、作用域链</h2>[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链 接，我们把这种链式链接叫做作用域链。在哪个函数里边查找变量，就去哪个函数的 作用域链顶端依次向下查找。<br>举例：<pre><code>function a(){  function b(){      function c(){          }      c();   }  b();}a();解析:a 函数被定义:a. [[scope]]-------&gt;0:GOa 函数执行前:a. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数被定义:b. [[scope]]-------&gt;0:a 的 AO                             1:GOb 函数执行前:b. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数被定义:c. [[scope]]-------&gt;0:b 的 AO                             1:a的AO                             2:GOc 函数执行前:c. [[scope]]-------&gt;0:c 的 AO                             1:b的AO                              2:a的AO 3:GO</code></pre><h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2>当内部函数被保存到外部时，就会生成闭包，闭包会导致原有作用域链不释放，造成 内存泄露。<br>举例：<pre><code>function a(){  function b(){      var bbb = 234;      console.log(aaa);   }  var aaa = 123;  return b; }var glob = 100;var demo = a();demo();</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://upload-images.jianshu.io/upload_images/13449852-7c9bd07540d3e4e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20200726-104858@2x.png"></li></ul><h3 id="（1）实现公有变量，比如函数累加器"><a href="#（1）实现公有变量，比如函数累加器" class="headerlink" title="（1）实现公有变量，比如函数累加器:"></a>（1）实现公有变量，比如函数累加器:</h3><pre><code>function add(){     var count = 0;    function demo(){        count ++;        console.log(count);        }    return demo;}var counter = add();counter();counter();counter();</code></pre><h3 id="（2）可以做缓存（存储结构）"><a href="#（2）可以做缓存（存储结构）" class="headerlink" title="（2）可以做缓存（存储结构）"></a>（2）可以做缓存（存储结构）</h3><pre><code>function eater(){       var food = "";      var obj = {             eat:function (){                 console.log("I am eating " + food);                 food = "";             },            push:function (myFood){                 food = myFood;            }       }      return obj;  }var eater1 = eater();eater1.push("banana");eater1.eat();</code></pre><h3 id="（3）可以实现封装，属性私有化"><a href="#（3）可以实现封装，属性私有化" class="headerlink" title="（3）可以实现封装，属性私有化"></a>（3）可以实现封装，属性私有化</h3><h3 id="（4）模块化开发，防止污染全局变量"><a href="#（4）模块化开发，防止污染全局变量" class="headerlink" title="（4）模块化开发，防止污染全局变量"></a>（4）模块化开发，防止污染全局变量</h3><h1 id="三、立即执行函数"><a href="#三、立即执行函数" class="headerlink" title="三、立即执行函数"></a>三、立即执行函数</h1><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>JS 给我们提供了一类函数，叫立即执行函数，这种函数执行完 马上就释放了，是针对初始化功能的函数，不占用内存空间。</p><h3 id="（1）形式"><a href="#（1）形式" class="headerlink" title="（1）形式"></a>（1）形式</h3><pre><code>(function (){}())</code></pre><p>可以添加参数</p><pre><code>(function (a,b){    console.log(a+b);}(1,2))</code></pre><p>同样也是有返回值的</p><pre><code>var num = (function (a,b){         var d = a + b;        return d; }(1,2))</code></pre><h3 id="（2）写法"><a href="#（2）写法" class="headerlink" title="（2）写法"></a>（2）写法</h3><pre><code>第一种：(function (){}())        W3C组织建议第二种：(function (){})() </code></pre><h3 id="（3）拓展：只有表达式才能被符号执行"><a href="#（3）拓展：只有表达式才能被符号执行" class="headerlink" title="（3）拓展：只有表达式才能被符号执行"></a>（3）拓展：只有表达式才能被符号执行</h3><p>举例：</p><pre><code>function test(){      console.log(1);}()//报错</code></pre><pre><code>var test= function (){      console.log(1);}()//执行</code></pre><pre><code>+ function test(){      console.log(1);}()</code></pre><p>本来他是函数声明，但是你在前边加上正号他就理论上转换为数字了，那他就是一个 表达式，你再后边直接加()就会执行，变成立即执行函数，然后忽略函数名，你执行 完后输出 test 就会报错，当然前边加上-或者!都可以，&amp;&amp;和||也可以，不过两边都要有东西，但是*和/不行，这里的+-代表正负号。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first article</title>
      <link href="/posts/bd8.html"/>
      <url>/posts/bd8.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><h3 id="Post-new-articles"><a href="#Post-new-articles" class="headerlink" title="Post new articles"></a>Post new articles</h3><pre class=" language-bash"><code class="language-bash">$  hexo cl <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo d </code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
